<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithm on Dale的水硕日记</title><link>https://shyu216.github.io/aquamega/tags/algorithm/</link><description>Recent content in Algorithm on Dale的水硕日记</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 15 Jun 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://shyu216.github.io/aquamega/tags/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Linear Programming</title><link>https://shyu216.github.io/aquamega/p/linear-programming/</link><pubDate>Sat, 15 Jun 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/linear-programming/</guid><description>&lt;h2 id="linear-program">Linear Program
&lt;/h2>&lt;p>最大流问题可以被表述为一个线性规划问题。线性规划是一种优化问题，目标是在一组线性约束条件下最大化或最小化一个线性目标函数。&lt;/p>
&lt;p>对于最大流问题，我们可以定义以下的线性规划模型：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>变量：对于每条边 e，我们定义一个变量 f(e)，表示边 e 的流量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>目标函数：我们的目标是最大化从源点 s 到汇点 t 的总流量，即最大化 ∑f(e)，其中求和是对所有从 s 出发的边 e 进行的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>约束条件：我们有两种类型的约束条件：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>容量约束：对于每条边 e，我们有 f(e) ≤ c(e)，其中 c(e) 是边 e 的容量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>流量守恒约束：对于图中的每个非源非汇节点 v，我们有 ∑f(e_in) = ∑f(e_out)，其中 e_in 是进入节点 v 的边，e_out 是离开节点 v 的边。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>以下是对应的线性规划模型：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">maximize ∑f(e) for all e from s
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">subject to
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">f(e) ≤ c(e) for all e
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">∑f(e_in) = ∑f(e_out) for all v ≠ s, t
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">f(e) ≥ 0 for all e
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个模型可以使用各种线性规划算法来解决，例如单纯形法（Simplex Method）或内点法（Interior Point Method）。&lt;/p>
&lt;h2 id="vertex-cover">Vertex Cover
&lt;/h2>&lt;p>顶点覆盖（Vertex Cover）是图论中的一个重要概念。&lt;/p>
&lt;p>在一个图中，顶点覆盖是一个顶点的集合，这个集合的特性是图中的每一条边至少有一个端点在这个集合中。换句话说，如果你从这个集合中选出一个顶点，你可以覆盖到至少一条边。&lt;/p>
&lt;p>例如，考虑一个简单的图，它有四个顶点（A, B, C, D）和四条边（AB, BC, CD, DA）。在这个图中，{A, B, C, D} 是一个顶点覆盖，因为每一条边都至少有一个端点在这个集合中。同样，{A, C} 或者 {B, D} 也是顶点覆盖。&lt;/p>
&lt;p>顶点覆盖问题是寻找一个最小的顶点覆盖，也就是包含最少顶点的覆盖。这是一个 NP 完全问题，意味着没有已知的多项式时间算法可以解决所有的顶点覆盖问题。然而，有一些启发式算法和近似算法可以在实际中有效地解决顶点覆盖问题，例如贪心算法。&lt;/p>
&lt;h3 id="max-matching-for-factor-2-approximation">Max Matching for Factor 2 Approximation
&lt;/h3>&lt;p>最大匹配（Max Matching）是图论中的一个重要概念。在一个图中，一个匹配是一个边的集合，其中每个顶点最多与一条边相连。最大匹配是一个具有最大边数的匹配。&lt;/p>
&lt;p>一个简单的近似算法是找到一个最大匹配，然后将匹配中的每条边的两个端点都加入顶点覆盖。这个算法的解至多是最优解的两倍。&lt;/p>
&lt;p>这个算法的正确性可以通过以下两点来证明：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>它是一个覆盖：假设不是，那么存在一条没有被覆盖的边。但是，这条边应该被加入到最大匹配中，因为它不与当前匹配中的任何边共享端点。这就产生了矛盾，所以这个假设是错误的，这个集合确实是一个覆盖。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>它至多是最优解的两倍：因为每条匹配的边都贡献了两个顶点到覆盖中，所以覆盖的大小是匹配的大小的两倍。而最大匹配的大小至少是任何顶点覆盖的大小（因为每个覆盖的顶点至多可以覆盖一条匹配的边），所以这个覆盖的大小至多是最优覆盖的大小的两倍。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="lp-relaxation-for-vertex-cover">LP Relaxation for Vertex Cover
&lt;/h3>&lt;p>在线性规划版本的顶点覆盖问题中，我们的目标是找到一组𝑦𝑣的值（对应每个顶点𝑣），使得对于每条边(u,v)，都有𝑦𝑢 + 𝑦𝑣 ≥ 1，并且∑𝑦𝑣尽可能小。&lt;/p>
&lt;p>当𝑦𝑣的值小于0.5时，这并不意味着会违反𝑦𝑢 + 𝑦𝑣 ≥ 1的条件。因为即使一个顶点的𝑦值小于0.5，只要它连接的另一个顶点的𝑦值大于0.5，那么这条边仍然可以被覆盖。换句话说，𝑦𝑢 + 𝑦𝑣 ≥ 1的条件是针对每条边来说的，而不是针对每个顶点。&lt;/p>
&lt;p>所以，即使𝑦𝑣的值小于0.5，只要找到的这组𝑦𝑣的值满足对于每条边(u,v)，都有𝑦𝑢 + 𝑦𝑣 ≥ 1，那么就不会违反这个条件。&lt;/p>
&lt;p>这是一个关于图论中顶点覆盖问题的线性规划近似解法的问题。这个方法的基本步骤如下：&lt;/p>
&lt;ol>
&lt;li>写出顶点覆盖问题的线性规划（LP）形式。&lt;/li>
&lt;li>在多项式时间内解决这个LP问题。&lt;/li>
&lt;li>在多项式时间内对LP解进行四舍五入，损失因子为2。&lt;/li>
&lt;/ol>
&lt;p>这个方法被称为2-近似解法，原因如下：&lt;/p>
&lt;p>顶点覆盖问题的目标是找到一个最小的顶点集合，使得图中的每条边都至少与集合中的一个顶点相连。在LP解法中，每个顶点被赋予一个0到1之间的值，表示这个顶点被选中的可能性。然后，我们将这些值四舍五入到最近的整数，得到一个顶点覆盖的近似解。&lt;/p>
&lt;p>这个方法的近似比例为2，是因为四舍五入操作可能会导致选中的顶点数目增加。具体来说，如果一个顶点在LP解中的值为0.5，那么在四舍五入后，这个顶点可能会被选中，从而增加了顶点覆盖的大小。然而，由于每个顶点的值都不会超过1，所以这个增加的数量最多不会超过原始LP解的两倍。因此，这个方法被称为2-近似解法。&lt;/p>
&lt;h2 id="set-cover">Set Cover
&lt;/h2>&lt;p>集合覆盖（Set Cover）是计算机科学中的一个经典问题，它是 NP 完全问题的一个例子。&lt;/p>
&lt;p>给定一个有限集合 U 和 U 的若干子集 S1, S2, &amp;hellip;, Sn，集合覆盖问题是要找到最小的子集合的集合，使得这些子集合的并集等于 U。&lt;/p>
&lt;p>例如，如果 U = {1, 2, 3, 4, 5}，S1 = {1, 2, 3}，S2 = {2, 4}，S3 = {3, 4, 5}，那么 {S1, S3} 就是一个集合覆盖，因为 S1 和 S3 的并集等于 U。&lt;/p>
&lt;p>集合覆盖问题在许多实际问题中都有应用，例如在无线网络设计、数据库系统、信息检索等领域。在这些问题中，我们通常希望找到一个最小的集合覆盖，以最小化成本或资源使用。&lt;/p>
&lt;p>集合覆盖问题是 NP 完全问题，这意味着没有已知的多项式时间算法可以解决所有的集合覆盖问题。然而，有一些启发式算法和近似算法可以在实际中有效地解决集合覆盖问题，例如贪心算法。&lt;/p>
&lt;h2 id="lp-relaxation-for-set-cover">LP Relaxation for Set Cover
&lt;/h2>&lt;p>这是关于集合覆盖问题的贪心算法近似解法的问题。集合覆盖问题是一个NP完全问题，其决策版本的目标是找到一个最小的子集合，使得这些子集合的并集等于全集。&lt;/p>
&lt;p>贪心算法的基本步骤如下：&lt;/p>
&lt;ol>
&lt;li>初始化一个空的解决方案。&lt;/li>
&lt;li>在每一步，选择一个对当前解决方案贡献最大的集合，将其添加到解决方案中。这里的&amp;quot;贡献&amp;quot;是指该集合包含的、在当前解决方案中尚未被覆盖的元素数量（如果是加权版本，则还需要除以集合的权重）。&lt;/li>
&lt;li>重复第2步，直到全集被覆盖。&lt;/li>
&lt;/ol>
&lt;p>这个贪心算法的近似比例为1 + ln n，其中n是全集的元素数量。这是因为在每一步，我们总是选择贡献最大的集合，这保证了我们的解决方案不会比最优解差太多。具体来说，无论最优解需要多少个集合k，这个算法总是返回一个至多为k(1 + ln n)的解决方案。&lt;/p>
&lt;p>更严格的分析表明，这个算法的近似因子实际上是(ln n - ln ln n) + Θ(1)。这意味着，随着n的增大，这个算法的性能会逐渐接近最优解。&lt;/p>
&lt;p>然而，已经证明，除非P=NP，否则集合覆盖问题不能在1 - o(1) ⋅ ln n的范围内被近似。这意味着，我们不能期望有一个在多项式时间内运行的近似算法，其近似因子的增长速度比c ⋅ ln n慢，其中c &amp;lt; 1。&lt;/p>
&lt;p>这是关于贪心算法在集合覆盖问题中的近似比例证明的问题。证明的基本思路如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>假设最优解包含k个集合。在每一次贪心迭代中，未被覆盖的元素数量会减少一个因子1 - 1/k。这是因为我们总是选择贡献最大的集合，而这个集合至少包含了最优解中每个集合的平均贡献。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于我们开始时有n个未被覆盖的元素，所以在进行k ln n次迭代后，所有的元素都会被覆盖。这里的ln n是因为在每次迭代中，未被覆盖的元素数量都会减少一个因子1 - 1/k，所以需要ln n次迭代才能将这个数量减少到1以下。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于实际的迭代次数可能不是整数，所以我们需要向上取整，得到⌈k ln n⌉。这意味着，我们的解决方案的大小最多为最优解的1 + ln n倍。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这个证明表明，贪心算法在集合覆盖问题中的近似比例为1 + ln n，这是一个对数级别的近似比例。这也解释了为什么这个算法被称为对数级别的贪心算法。&lt;/p>
&lt;h2 id="duality">Duality
&lt;/h2>&lt;p>线性规划的对偶性是一个非常重要的概念。对于每一个线性规划问题（称为原问题），都存在一个相关的线性规划问题（称为对偶问题）。原问题和对偶问题之间有一些非常有趣的关系。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>对偶问题的目标函数是原问题的约束条件的线性组合，反之亦然。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对偶问题的解（对偶值）提供了原问题解（原值）的一个下界（如果是最大化问题）或上界（如果是最小化问题）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果原问题和对偶问题都有解（即它们是可行的），那么它们的最优解是相等的。这就是所谓的弱对偶性。如果原问题是无界的，那么对偶问题是不可行的，反之亦然。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在某些条件下（例如，如果原问题和对偶问题都满足某些正则性条件），我们可以保证强对偶性，即原问题的任何可行解和对偶问题的任何可行解都有相同的目标函数值。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这些对偶性质在解决线性规划问题时非常有用。例如，它们可以用来检验解的最优性，提供解的上下界，以及通过解对偶问题来更有效地解原问题。&lt;/p>
&lt;h2 id="近似算法">近似算法
&lt;/h2>&lt;p>近似算法是一种在有限时间内找到最优解的近似解的算法。在许多情况下，找到最优解可能需要非常长的时间，或者甚至是不可能的。在这种情况下，近似算法可以提供一个可接受的、接近最优的解。近似算法的一个主要优点是它们通常可以在多项式时间内运行，这使得它们在处理大规模问题时非常有用。&lt;/p>
&lt;h2 id="lps-作为有效的松弛">LPs 作为有效的松弛
&lt;/h2>&lt;p>在优化问题中，松弛是一种将一个难以解决的问题转化为一个更容易解决的问题的技术。线性规划可以作为一种有效的松弛技术，将一些难以直接解决的问题转化为线性规划问题。通过这种方式，我们可以利用线性规划的强大求解能力来解决更复杂的问题。&lt;/p>
&lt;h2 id="舍入对偶拟合原始-对偶方法">舍入、对偶拟合、原始-对偶方法
&lt;/h2>&lt;p>这些都是处理线性规划问题的技术。舍入是一种将连续解转化为离散解的方法；对偶拟合是一种通过解对偶问题来找到原问题解的方法；原始-对偶方法是一种同时解原问题和对偶问题的方法。这些技术都是为了在实际应用中更好地解决线性规划问题。&lt;/p></description></item><item><title>Max-Flow Min-Cut Theorem</title><link>https://shyu216.github.io/aquamega/p/max-flow-min-cut-theorem/</link><pubDate>Tue, 11 Jun 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/max-flow-min-cut-theorem/</guid><description>&lt;p>&lt;strong>请注意&lt;/strong>！本文是由公元2024年的GPT生成的，可能包含一些不准确的信息。&lt;/p>
&lt;p>最大流（Max-Flow）问题和最小割（Min-Cut）问题在网络流中是两个互相关联的问题，它们的关系通常被称为最大流-最小割定理（Max-Flow Min-Cut Theorem）。&lt;/p>
&lt;p>最大流-最小割定理是网络流中的一个基本定理，它指出了一个网络的最大流量和该网络的最小割的容量之间的关系。具体来说，对于任何网络，其最大流量等于其最小割的容量。&lt;/p>
&lt;p>在一个网络流图中，流量从源节点（source）流向汇节点（sink）。最大流问题就是要找到一种流的分配方式，使得从源节点到汇节点的总流量最大。&lt;/p>
&lt;p>割（cut）是将网络图分割成两部分的一种方式，其中一部分包含源节点，另一部分包含汇节点。割的容量（capacity）是从源节点部分到汇节点部分的所有边的容量之和。最小割问题就是要找到一种割的方式，使得割的容量最小。&lt;/p>
&lt;h2 id="kargers-algorithm-for-min-cut">Karger&amp;rsquo;s Algorithm for Min Cut
&lt;/h2>&lt;p>David Karger 的最小割算法是一种随机化算法，用于在无向图中找到最小割。这个算法基于一种称为“边收缩”（edge contraction）的操作。&lt;/p>
&lt;p>这个算法的期望运行时间是多项式的，但是它可能需要多次运行才能找到真正的最小割。为了提高找到最小割的概率，我们可以多次运行这个算法，并返回所有运行中找到的最小割。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Adjacency list&lt;/p>
&lt;p>邻接列表是一种表示图的方法，它为图中的每个顶点维护一个列表，列出了从该顶点出发可以到达的所有顶点。在 Python 中，我们通常使用字典来实现邻接列表，其中键是顶点，值是一个列表，包含了所有连接到该顶点的顶点。邻接列表是一种空间效率高的数据结构，特别适合于稀疏图，即边的数量远小于顶点的数量的平方的图。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Union-Find&lt;/p>
&lt;p>并查集是一种用于处理不相交集合的数据结构。它支持两种操作：查找和合并。查找操作 Find(x) 用于找到包含元素 x 的集合的代表元素。合并操作 Merge(x, y) 用于将包含元素 x 和 y 的两个集合合并为一个集合。并查集的一个重要特性是，这两种操作的时间复杂度都接近于常数，这使得它在处理大规模数据时非常高效。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="greedy-algorithm-for-max-flow">Greedy Algorithm for Max Flow
&lt;/h2>&lt;ol>
&lt;li>初始化所有边的流量为0。&lt;/li>
&lt;li>寻找一条从源点s到目标点t的路径，这条路径上的每一条边的流量都小于其容量。&lt;/li>
&lt;li>沿着找到的这条路径尽可能多地增加流量，找到路径上剩余容量最小的边，然后增加这个量的流量。&lt;/li>
&lt;/ol>
&lt;p>我们重复以上步骤，直到无法找到满足条件的路径为止。&lt;/p>
&lt;ul>
&lt;li>无法保证最优。贪心算法可能会选择一条在当前看来可以增加最多流量的路径。然而，这可能会导致在后续的步骤中，无法找到新的路径来进一步增加流量。&lt;/li>
&lt;/ul>
&lt;h2 id="ford-fulkerson-algorithm-for-max-flow">Ford-Fulkerson Algorithm for Max Flow
&lt;/h2>&lt;p>Ford-Fulkerson 算法是一种解决最大流问题的经典方法。这个算法的基本步骤如下：&lt;/p>
&lt;ol>
&lt;li>初始流设为零。&lt;/li>
&lt;li>只要在残余网络中存在一条从源节点 s 到汇点 t 的路径，就执行以下操作：
&lt;ul>
&lt;li>寻找一条可以增加流量的路径。&lt;/li>
&lt;li>更新流量和残余网络。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>返回最后计算出的流量。&lt;/li>
&lt;/ol>
&lt;h3 id="proofs">Proofs
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>在每一次迭代中，流量都是整数：这可以通过数学归纳法来证明。初始的流量是零，是一个整数。在每次迭代中，我们都在一条路径上增加整数的流量，所以流量始终是整数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在每次迭代中，流量增加了 KP：这可以通过观察源节点 s 和路径来证明。在每次迭代中，我们都在一条从 s 到 t 的路径上增加流量，所以总流量会增加。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>算法会在有限的步骤后停止（最多在 𝐶 = ∑(对所有边的容量𝑐求和) 迭代后）：这可以从前面的证明推断出来。因为每次迭代都会增加流量，而总流量受到网络容量的限制，所以算法一定会在有限的步骤后停止。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="running-time">Running time
&lt;/h3>&lt;p>Ford-Fulkerson（FF）算法的运行时间取决于多个因素，包括图的结构、边的容量以及选择增广路径的策略。在每次迭代中，算法需要在残余图中找到一条源节点s到目标节点t的路径，然后根据这条路径更新流量和残余图。&lt;/p>
&lt;p>每次迭代的时间复杂度为O(m)，其中m是图中的边的数量，原因如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在残余图中找到一条s-t路径：这可以通过深度优先搜索（DFS）或广度优先搜索（BFS）来完成，时间复杂度为O(m)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>更新流量和残余图：一旦找到了一条增广路径，我们需要遍历这条路径上的所有边，更新它们的流量和残余容量。这个过程的时间复杂度也为O(m)，因为一条路径上的边的数量最多为m。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>因此，每次迭代的时间复杂度为O(m)。然而，需要注意的是，FF算法的总运行时间并不是多项式时间，因为算法的迭代次数取决于最大流量，而这可能远大于图的大小。&lt;/p>
&lt;p>循环的次数最多是 C，其中 C 是图中所有边的容量之和。这是因为在每次循环中，我们至少增加一单位的流量，因此最多需要 C 次循环。&lt;/p>
&lt;p>因此，总的运行时间是 O(Cm)。而实际情况一般是线性时间。&lt;/p>
&lt;h4 id="flow-vs-cut">Flow vs Cut
&lt;/h4>&lt;p>在最大流最小割定理中，流等于割是因为在流网络中，流的大小受限于割的容量。这个定理告诉我们，任何流网络的最大流都等于其某个割的最小容量。&lt;/p>
&lt;p>这是因为：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>流的大小不能超过任何割的容量。这是因为割定义了从源点到汇点的所有可能的路径，流必须通过这些路径，因此不能超过割的容量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在最大流的情况下，存在一个割，其容量等于流的大小。这是因为当我们找到最大流时，我们已经找到了一种方式，使得所有从源点到汇点的路径都被充分利用，这就形成了一个割。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>在最大流最小割定理中，可达性（reachability）的概念是非常重要的。我们可以通过以下步骤使用可达性来证明这个定理：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先，我们找到流网络中的一个最大流。在这个流中，我们可以找到一个割，即一个将网络分割成两部分的边集，使得所有的流都从割的一边（源点所在的一边）流向另一边（汇点所在的一边）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后，我们考虑在残余网络中从源点开始的可达性。在残余网络中，一个节点是可达的，如果存在一条从源点到该节点的路径，路径上的所有边在残余网络中都有正的容量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在最大流的情况下，汇点在残余网络中是不可达的，因为所有的流都已经达到了最大值，没有更多的容量可以从源点流向汇点。这意味着存在一个割，将可达的节点和不可达的节点分开，割的容量等于最大流的值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因此，我们证明了最大流等于最小割。这是因为我们找到了一个割，其容量等于最大流的值，而任何其他割的容量必须大于或等于这个值，因为流的大小不能超过割的容量。所以，这个割就是最小割，其容量（即最小割的值）等于最大流的值。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="flow-value-lemma">Flow-Value Lemma
&lt;/h4>&lt;p>流量值引理（Flow-Value Lemma）是网络流问题中的一个重要概念，它描述了流入和流出一个节点的总流量之间的关系。&lt;/p>
&lt;p>流量值引理的内容如下：&lt;/p>
&lt;p>对于任何流网络中的节点 v（除了源点 s 和汇点 t），流入节点 v 的总流量等于流出节点 v 的总流量。这个性质也被称为流的守恒性质，因为它意味着除了源点和汇点之外，没有流量在任何节点处被创建或消失。&lt;/p>
&lt;p>数学上，这可以表示为：&lt;/p>
&lt;p>对于所有节点 v（v ≠ s, v ≠ t），∑&lt;em>{u ∈ V} f(u, v) = ∑&lt;/em>{u ∈ V} f(v, u)&lt;/p>
&lt;p>其中 V 是节点的集合，f(u, v) 是从节点 u 到节点 v 的流量。&lt;/p>
&lt;p>这个引理是网络流问题中的基本性质，它是许多网络流算法，包括 Ford-Fulkerson 算法和 Edmonds-Karp 算法的基础。&lt;/p>
&lt;h4 id="weak-duality">Weak Duality
&lt;/h4>&lt;p>弱对偶性（Weak Duality）在流量值特征（flow value characterization）中的应用是网络流问题的一个重要概念。它提供了流量值的一个上界。&lt;/p>
&lt;p>弱对偶性定理的内容如下：&lt;/p>
&lt;p>对于任何流网络和任何割（s-t cut），流量值总是小于或等于割的容量。换句话说，最大流的值总是小于或等于最小割的值。&lt;/p>
&lt;p>在流量值特征中，这个定理意味着我们可以通过寻找最小割来得到流量值的一个上界。这个上界对于理解和解决网络流问题非常有用，因为它提供了一个我们无法超过的流量值。&lt;/p>
&lt;p>此外，这个定理还证明了最大流最小割定理（Max-Flow Min-Cut Theorem）的一部分。最大流最小割定理是网络流问题中的一个重要定理，它表明在任何流网络中，最大流的值等于最小割的值。弱对偶性定理证明了这个定理的“小于等于”部分，而“等于”部分需要通过 Ford-Fulkerson 算法或其变种来证明。&lt;/p>
&lt;h3 id="optimality">Optimality
&lt;/h3>&lt;p>所有穿过割的边要么是从 A 到 B 并且满流，要么是从 B 到 A 并且空流。&lt;/p>
&lt;h2 id="perfect-matchings">Perfect Matchings
&lt;/h2>&lt;p>在图论中，&amp;ldquo;匹配&amp;rdquo;（Matching）是指图的一个边的子集，使得子集中的任意两条边都不共享顶点。这是一种将图中的一部分顶点配对的方式，每对配对都通过一条边连接。匹配不一定需要包含图中的所有顶点。&lt;/p>
&lt;p>&amp;ldquo;完美匹配&amp;rdquo;（Perfect Matching）是匹配的一种特殊情况。在完美匹配中，图的每个顶点都恰好与子集中的一条边相连。换句话说，如果一个图有 n 个顶点，那么它的一个完美匹配就会有 n/2 条边。&lt;/p>
&lt;p>完美匹配在许多问题中都有应用，例如在网络设计、任务分配、市场匹配等问题中。在这些问题中，我们通常希望找到一个完美匹配，使得某种成本或效益最优化。&lt;/p>
&lt;p>例如，二分图的最大匹配问题就是要找到一个最大的匹配，即一个最大的边集，使得集合中的任意两条边都不共享端点。这个问题可以通过将其转化为最大流问题来解决。&lt;/p>
&lt;h2 id="bipartite-matching">Bipartite Matching
&lt;/h2>&lt;p>二分匹配（Bipartite Matching）是图论中的一个重要概念，它是在二分图（Bipartite Graph）中进行的匹配。&lt;/p>
&lt;p>二分图是一种特殊的图，它的所有顶点可以被分成两个互不相交的集合，使得每一条边的两个端点分别属于这两个不同的集合。在二分图中进行匹配，就是找到边的集合，使得在这个集合中的任意两条边都不共享端点。&lt;/p>
&lt;p>二分匹配有许多实际应用，例如在任务分配、稳定婚姻问题、市场均衡等问题中都有应用。在这些问题中，我们通常希望找到一个最大的匹配，也就是包含最多边的匹配。&lt;/p>
&lt;p>加s和t就能当max-flow问题解了。&lt;/p>
&lt;p>&amp;ldquo;请说&amp;rsquo;相邻&amp;rsquo;而不是&amp;rsquo;连接&amp;rsquo;&amp;quot;：在图论中，&amp;ldquo;相邻&amp;quot;和&amp;quot;连接&amp;quot;这两个词有着不同的含义。如果两个节点之间有一条边，我们通常说这两个节点是&amp;quot;相邻&amp;quot;的。而&amp;quot;连接&amp;quot;通常指的是在一个图中，存在一条路径可以从一个节点到达另一个节点。&lt;/p>
&lt;p>&amp;ldquo;避免使用&amp;rsquo;任何&amp;rsquo;这个词&amp;rdquo;：在描述算法时，&amp;ldquo;任何&amp;quot;这个词可能会引起混淆。比如，如果我们说&amp;quot;任何节点都可以到达任何其他节点&amp;rdquo;，这可能会被误解为在图中存在一条从每个节点到每个其他节点的直接边，而实际上我们可能只是想表达在图中存在一条从每个节点到每个其他节点的路径。&lt;/p>
&lt;h3 id="integrality-theorem">Integrality Theorem
&lt;/h3>&lt;p>整数定理（Integrality Theorem）是网络流问题中的一个重要定理，它表明如果所有边的容量都是整数，那么存在一个最大流，使得每条边的流量也都是整数。&lt;/p>
&lt;p>如果 k 是整数，并且我们只考虑容量为 1 的边，那么每条边的流量 f(e) 必须是 0 或 1。原因是流量必须满足容量约束，也就是说，流量不能超过容量。因此，如果容量为 1，那么流量只能是 0 或 1。&lt;/p>
&lt;p>这个性质在解决一些特殊的网络流问题时非常有用，例如在匹配问题和路由问题中。在这些问题中，我们通常只关心是否存在一条边，而不关心边的具体容量，所以我们可以将所有边的容量设为 1，然后应用整数定理。&lt;/p>
&lt;h3 id="match-to-flow">Match to Flow
&lt;/h3>&lt;p>这个定理表明，在图 G 中的最大匹配数等于在 G&amp;rsquo; 中的最大流量。这个定理的证明分为两部分：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>≤：将最大匹配转化为流量。匹配约束确保我们满足流量约束。匹配约束和匹配大小确保流量值等于匹配大小。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>≥：将最大流量转化为匹配。流量整数性确保我们不会选择边的分数部分。流网络的约束（容量，保守性）确保我们满足匹配约束（每个顶点最多只能与一个匹配边相邻）。流量值引理表明匹配的大小等于流量的值。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这个定理说明了匹配问题和网络流问题之间的深刻联系。通过将匹配问题转化为网络流问题，我们可以使用网络流算法，如 Ford-Fulkerson 算法和 Edmonds-Karp 算法，来解决匹配问题。这种转化方法在解决一些复杂的组合优化问题时非常有用。&lt;/p>
&lt;h2 id="disjoint-paths">Disjoint Paths
&lt;/h2>&lt;p>在图论中，&amp;ldquo;不相交路径&amp;rdquo;（Disjoint Paths）是指一组路径，其中任意两条路径都没有共享的顶点或边。换句话说，这些路径是完全独立的，它们不会在任何地方交叉或重叠。&lt;/p>
&lt;p>不相交路径的概念在许多问题中都有应用，例如在网络设计、路由问题、交通规划等问题中。在这些问题中，我们通常希望找到一组不相交的路径，以便最大化网络的吞吐量，或者避免交通拥堵。&lt;/p>
&lt;p>在有向图中，我们可以通过最大流算法来找出k条边不相交的路径。这个问题可以转化为一个容量为1的最大流问题。&lt;/p>
&lt;p>以下是证明过程：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>只需证明&lt;/strong>：假设我们有k条不相交的路径。我们可以在每条路径上路由一单位的流，不需要其他流。因此，最大流至少为k。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>如果证明&lt;/strong>：假设最大流至少为k。我们需要证明存在至少k条不相交的路径。为了证明这一点，我们可以对携带流的边的数量进行归纳。&lt;/p>
&lt;p>归纳基础：如果最大流为1，那么存在一条从s到t的路径。&lt;/p>
&lt;p>归纳步骤：假设对于所有小于k的最大流，都存在相应数量的不相交路径。现在，我们考虑最大流为k的情况。由于流的整数性质，我们知道存在一条边，其流量为1，我们可以移除这条边，并将总流量减少1。根据归纳假设，剩余的图存在k-1条不相交的路径。加上我们刚才移除的那条边，我们就找到了k条不相交的路径。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>因此，我们可以得出结论：在有向图中，存在k条边不相交的路径当且仅当最大流至少为k。&lt;/p>
&lt;h2 id="scaling-max-flow">Scaling Max Flow
&lt;/h2>&lt;p>在解决最大流问题时，一种常用的策略是使用缩放（Scaling）技术。这种技术的基本思想是先解决一个简化的问题，然后逐步增加问题的规模，直到解决原始问题。&lt;/p>
&lt;p>在最大流问题中，缩放技术通常是这样实现的：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先，我们找到网络中最大的容量 C。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后，我们设置一个阈值，初始值为 C。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我们只考虑容量大于或等于阈值的边，忽略其他边，然后使用 Ford-Fulkerson 算法或 Edmonds-Karp 算法找到这个简化网络的最大流。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后，我们将阈值减半，再次运行最大流算法。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我们重复这个过程，直到阈值为 1。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这种方法的优点是，每次迭代时，我们只需要考虑一部分边，这可以大大减少计算量。此外，由于我们是从大到小逐步减小阈值，所以我们可以利用前一次迭代的结果，这可以进一步提高效率。&lt;/p>
&lt;p>这种方法在处理大规模网络流问题时非常有效，特别是当网络中的容量差异很大时。&lt;/p>
&lt;h2 id="edmonds-karp-algorithm">Edmonds-Karp Algorithm
&lt;/h2>&lt;ol>
&lt;li>找最宽的路径。Dijkstra,$O(m^2lognlogF)$&lt;/li>
&lt;li>找最短的路径。BFS,$O(m^2n)$&lt;/li>
&lt;/ol>
&lt;h2 id="applications">Applications
&lt;/h2>&lt;h3 id="circulation-with-demands">Circulation with Demands
&lt;/h3>&lt;p>多个源点和汇点的网络流问题是网络流问题的一个重要变种。在这个问题中，我们有多个源点和多个汇点，每个源点都有一个流出的需求，每个汇点都有一个流入的需求。我们的目标是找到一种流的分配方式，使得每个源点的流出等于需求，每个汇点的流入等于需求。&lt;/p>
&lt;h2 id="halls-theorem">Hall’s Theorem
&lt;/h2>&lt;p>哈尔定理（Hall&amp;rsquo;s Theorem）是图论中的一个重要定理，主要用于解决二部图的完美匹配问题。它的内容如下：&lt;/p>
&lt;p>在一个二部图中，如果对于左侧的每个顶点集合，其邻接的右侧顶点集合的大小至少与其一样大，那么这个二部图存在一个完美匹配。&lt;/p>
&lt;p>更形式化地说，设 G=(V,E) 是一个二部图，V 可以分为两个部分 V1 和 V2。如果对于 V1 中的任意子集 S，都有 |N(S)| &amp;gt;= |S|，其中 N(S) 是 S 中所有顶点的邻接顶点集合，那么 G 中存在一个完美匹配。&lt;/p>
&lt;p>这个定理在组合优化、网络流和匹配理论等领域有广泛的应用。例如，它可以用来解决任务分配问题、婚配问题等。&lt;/p>
&lt;p>Hall定理是用于解决二部图中的完美匹配问题的，而流网络中的需求循环问题则需要使用不同的方法来解决。&lt;/p>
&lt;p>在流网络中，每个节点都有一个需求，表示流入该节点的流量和流出该节点的流量之间的差值。一个需求循环是一个满足所有节点需求的流。&lt;/p>
&lt;p>要解决需求循环问题，我们可以使用以下步骤：&lt;/p>
&lt;ol>
&lt;li>添加一个新的源节点s和一个新的汇点t。&lt;/li>
&lt;li>对于每个需求为d的节点v，如果d &amp;gt; 0，那么添加一条从s到v的边，容量为d；如果d &amp;lt; 0，那么添加一条从v到t的边，容量为-d。&lt;/li>
&lt;li>在新的网络中找到一个最大流。如果这个最大流的值等于所有正需求的总和，那么原网络存在一个需求循环。否则，原网络不存在需求循环。&lt;/li>
&lt;/ol>
&lt;p>这个方法的正确性基于最大流最小割定理：在一个流网络中，最大流的值等于最小割的容量。在这个问题中，最小割就是将所有正需求的节点和所有负需求的节点分开的割，其容量就是所有正需求的总和。所以，如果最大流的值等于所有正需求的总和，那么就存在一个需求循环。反之，如果存在一个需求循环，那么最大流的值必然等于所有正需求的总和。&lt;/p></description></item><item><title>COMP90054</title><link>https://shyu216.github.io/aquamega/p/comp90054/</link><pubDate>Sun, 09 Jun 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/comp90054/</guid><description>&lt;ul>
&lt;li>classical planning (blind/heuristic): &lt;a class="link" href="https://fai.cs.uni-saarland.de/hoffmann/papers/ki11.pdf" target="_blank" rel="noopener"
>https://fai.cs.uni-saarland.de/hoffmann/papers/ki11.pdf&lt;/a>&lt;/li>
&lt;li>PDDL&lt;/li>
&lt;li>relaxation&lt;/li>
&lt;li>reinforcement learning: &lt;a class="link" href="https://gibberblot.github.io/rl-notes/index.html" target="_blank" rel="noopener"
>https://gibberblot.github.io/rl-notes/index.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="vocabs">Vocabs
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>acyclic 无环&lt;/p>
&lt;/li>
&lt;li>
&lt;p>systematics 系统的 / local 局部&lt;/p>
&lt;/li>
&lt;li>
&lt;p>heuristic 启发式&lt;/p>
&lt;/li>
&lt;li>
&lt;p>monotonic 单调&lt;/p>
&lt;/li>
&lt;li>
&lt;p>priority queue = min heap&lt;/p>
&lt;/li>
&lt;li>
&lt;p>conformant 符合的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>policy 策略，map from state to action, denoted by $\pi$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>negation 否定&lt;/p>
&lt;/li>
&lt;li>
&lt;p>precondition 前提条件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>propositional 命题&lt;/p>
&lt;/li>
&lt;li>
&lt;p>predicate 谓词，return true/false&lt;/p>
&lt;/li>
&lt;li>
&lt;p>schema 模式，define somthing&lt;/p>
&lt;/li>
&lt;li>
&lt;p>misplace 放错&lt;/p>
&lt;/li>
&lt;li>
&lt;p>dominate 支配&lt;/p>
&lt;/li>
&lt;li>
&lt;p>corollary 推论&lt;/p>
&lt;/li>
&lt;li>
&lt;p>point-wise 逐点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>pessimistic 悲观&lt;/p>
&lt;/li>
&lt;li>
&lt;p>benchmark 基准&lt;/p>
&lt;/li>
&lt;li>
&lt;p>novelty 新颖性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>prune 修剪&lt;/p>
&lt;/li>
&lt;li>
&lt;p>velocity 速度&lt;/p>
&lt;/li>
&lt;li>
&lt;p>stochastic 随机&lt;/p>
&lt;/li>
&lt;li>
&lt;p>tabular 表格&lt;/p>
&lt;/li>
&lt;li>
&lt;p>dilemma 困境&lt;/p>
&lt;/li>
&lt;li>
&lt;p>equilibria 平衡&lt;/p>
&lt;/li>
&lt;li>
&lt;p>, set minus operation&lt;/p>
&lt;/li>
&lt;li>
&lt;p>payoff 收益&lt;/p>
&lt;/li>
&lt;li>
&lt;p>utility 效用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Nondeterministic Polynomial: 不确定多项式，没有已知的多项式时间算法可以在所有情况下找到一个解&lt;/p>
&lt;ul>
&lt;li>non-deterministic: countless outcomes&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>mixed strategy equilibria: 混合策略均衡&lt;/p>
&lt;/li>
&lt;li>
&lt;p>nash equilibrium: 纳什均衡，每个玩家都在最佳响应下(pure strategy)，没有人会改变策略&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="安全目标感知可接受一致性">安全/目标感知/可接受/一致性
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>$h$ remaining cost to reach the goal, $*$ optimal&lt;/p>
&lt;/li>
&lt;li>
&lt;p>假设$\Pi$是一个计划任务，具有状态空间$\Theta_{\Pi} = (S, L, c, T, I, G)$，并且$h$是$\Pi$的一个启发式。如果启发式满足以下条件，那么它被称为：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>安全（Safe）：如果对于所有$h(s) = \infty$的状态$s \in S$，都有$h^*(s) = \infty$，则启发式被称为安全。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>目标感知（Goal-aware）：如果对于所有目标状态$s \in S_G$，都有$h(s) = 0$，则启发式被称为目标感知。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可接受（Admissible）：如果对于所有状态$s \in S$，都有$h(s) \leq h^*(s)$，则启发式被称为可接受。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一致（Consistent）：如果对于所有$s \xrightarrow{a} s&amp;rsquo;$的转移，都有$h(s) \leq h(s&amp;rsquo;) + c(a)$，则启发式被称为一致。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>命题：假设$\Pi$是一个计划任务，具有状态空间$\Theta_{\Pi} = (S, L, c, T, I, S_G)$，并且$h$是$\Pi$的一个启发式。&lt;/p>
&lt;ul>
&lt;li>如果$h$是一致的和目标感知的，则$h$是可接受的。&lt;/li>
&lt;li>如果$h$是可接受的，则$h$是目标感知的。&lt;/li>
&lt;li>如果$h$是可接受的，则$h$是安全的。&lt;/li>
&lt;li>没有其他这种形式的蕴含关系成立。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>不可接受：最优的节点如果被高估，就会优先扩展其他节点，而错过最优。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一致性：保证最优路径依次访问。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="strips-问题是一个四元组p--langle-foig-rangle">STRIPS: 问题是一个四元组$P = \langle F,O,I,G \rangle$：
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>$F$ fact, 原子, 变量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$O$ 或 $A$ operator, action, 操作符, 动作&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$I \subseteq F$代表初始情况&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$G \subseteq F$代表目标情况&lt;/p>
&lt;/li>
&lt;li>
&lt;p>操作符$o \in O$由以下表示：&lt;/p>
&lt;ul>
&lt;li>添加列表$Add(o) \subseteq F$&lt;/li>
&lt;li>删除列表$Del(o) \subseteq F$&lt;/li>
&lt;li>前提条件列表$Pre(o) \subseteq F$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="relaxiation">Relaxiation:
&lt;/h2>&lt;p>Goal：Helps compute heuristic function。&lt;/p>
&lt;p>设$h^* : P \rightarrow R^+_0 \cup {\infty}$是一个函数。$h^&lt;em>$的松弛是一个三元组$R= (P&amp;rsquo;,r,h&amp;rsquo;^&lt;/em>)$，其中$P&amp;rsquo;$是任意集合，$r : P \rightarrow P&amp;rsquo;$和$h&amp;rsquo;^* : P&amp;rsquo; \rightarrow R^+_0 \cup {\infty}$是函数，对于所有的$\Pi \in P$，松弛启发式$h_R(\Pi) := h&amp;rsquo;^&lt;em>(r(\Pi))$满足$h_R(\Pi) \leq h^&lt;/em>(\Pi)$。松弛是：&lt;/p>
&lt;ul>
&lt;li>问题$P$：寻路。&lt;/li>
&lt;li>更简单的问题$P&amp;rsquo;$：鸟类的寻路。&lt;/li>
&lt;li>$P&amp;rsquo;$的完美启发式$h&amp;rsquo;^*$：直线距离。&lt;/li>
&lt;li>转换$r$：假装你是一只鸟。&lt;/li>
&lt;li>原生的，如果$P&amp;rsquo; \subseteq P$且$h&amp;rsquo;^* = h^*$；&lt;/li>
&lt;li>可有效构造的，如果存在一个多项式时间算法，给定$\Pi \in P$，可以计算$r(\Pi)$；&lt;/li>
&lt;li>可有效计算的，如果存在一个多项式时间算法，给定$\Pi&amp;rsquo; \in P&amp;rsquo;$，可以计算$h&amp;rsquo;^*(\Pi&amp;rsquo;)$。&lt;/li>
&lt;/ul>
&lt;p>提醒：你有一个问题$P$，你希望估计其完美启发式$h^&lt;em>$。你定义了一个更简单的问题$P&amp;rsquo;$，其完美启发式$h&amp;rsquo;^&lt;/em>$可以用来（可接受地！）估计$h^&lt;em>$。你定义了一个从$P$到$P&amp;rsquo;$的转换$r$。给定$\Pi \in P$，你通过$h&amp;rsquo;^&lt;/em>(r(\Pi))$来估计$h^*(\Pi)$。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>notation in this course&lt;/strong>:&lt;/p>
&lt;p>$\Pi_s$：将初始状态替换为$s$的$\Pi$，即，将$\Pi = (F,A,c,I,G)$更改为$(F,A,c,s,G)$。&lt;/p>
&lt;ul>
&lt;li>c: clause, preconditions+effects&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="有关quality-value的一些概念">有关Quality Value的一些概念：
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>Value：在强化学习中，value通常指的是一个状态的价值，也就是从这个状态开始，遵循某个策略能够获得的预期回报。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Q-value：Q-value是对于状态-动作对(state-action pair)的价值的一种评估。也就是说，如果在某个状态下执行某个动作，然后遵循某个策略，能够获得的预期回报。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Q-value table：Q-value table是一种数据结构，用于存储每个状态-动作对的Q-value。在表格型强化学习算法（如Q-learning）中，Q-value table是主要的数据结构。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Q-value function：Q-value function是一个函数，它接受一个状态和一个动作作为输入，返回这个状态-动作对的Q-value。在函数逼近方法（如深度Q网络）中，Q-value function通常由神经网络来表示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Q-table：Q-table和Q-value table是同一个概念，只是名称不同。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>COMP90077</title><link>https://shyu216.github.io/aquamega/p/comp90077/</link><pubDate>Sun, 09 Jun 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/comp90077/</guid><description>&lt;p>Learn some advanced algorithms and data structures.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Treap&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Admortized Analysis: Prepaid/Potential&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Quake Heap&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Splay Tree&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Perfect Hashing/Cuckoo Hashing&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Range Tree&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Min Cut/Max Flow&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Karger&amp;rsquo;s algorithm: 找最小割, 找多次取最优, 随机地找两个节点合并, 直到只剩下两个节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Ford-Fulkerson algorithm: 最早的最大流算法, 重复地找增广路径, 直到找不到&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Edmonds-Karp algorithm: 用BFS找增广路径, complexity更低&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Hall&amp;rsquo;s theorem: 一个二分图存在完美匹配当且仅当对于每一个子集, 子集的大小大于等于子集的邻居的大小&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="readings">Readings
&lt;/h2>&lt;ul>
&lt;li>Karger&amp;rsquo;s Randomised Contraction algorithm: Chapter 13.2 of [KT]&lt;/li>
&lt;li>Flow networks, max flow, min cut and basic Ford-Fulkerson: Chapter 7.1 - 7.2 of [KT] and also Chapter 10.1 - 10.4 of [JE]&lt;/li>
&lt;li>Flow network applications (Bipartite Matching and Disjoint Paths): Chapter 7.5-7.6 of [KT]&lt;/li>
&lt;li>Capacity-Scaling: Chapter 7.3 of [KT]Edmonds-Karps algorithms: Chapter 10.6 of [JE]&lt;/li>
&lt;li>Circulation with demands: Chapter 7.7 of [KT]&lt;/li>
&lt;li>Linear Programming: &lt;a class="link" href="https://jeffe.cs.illinois.edu/teaching/algorithms/notes/H-lp.pdf" target="_blank" rel="noopener"
>https://jeffe.cs.illinois.edu/teaching/algorithms/notes/H-lp.pdf&lt;/a>&lt;/li>
&lt;li>Approximation Algorithms: Chapter 1 of &lt;a class="link" href="https://www.designofapproxalgs.com/book.pdf" target="_blank" rel="noopener"
>https://www.designofapproxalgs.com/book.pdf&lt;/a> and see also Approximation Algorithms by Vazirani&lt;/li>
&lt;li>[JE] = &lt;a class="link" href="https://jeffe.cs.illinois.edu/teaching/algorithms/book/Algorithms-JeffE.pdf" target="_blank" rel="noopener"
>https://jeffe.cs.illinois.edu/teaching/algorithms/book/Algorithms-JeffE.pdf&lt;/a>&lt;/li>
&lt;li>[KT] = Algorithm Design by Kleinberg and Tardos&lt;/li>
&lt;/ul>
&lt;h2 id="vocabs">Vocabs
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>asymptotic notation: 渐进符号&lt;/p>
&lt;/li>
&lt;li>
&lt;p>subtle: 微妙的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>conjecture: 猜想&lt;/p>
&lt;/li>
&lt;li>
&lt;p>concave: 凹的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>invalidate: 使无效&lt;/p>
&lt;/li>
&lt;li>
&lt;p>conceptual: 概念上的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>dominate: 支配&lt;/p>
&lt;/li>
&lt;li>
&lt;p>trial: 尝试&lt;/p>
&lt;/li>
&lt;li>
&lt;p>prime: 素数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>evict: 驱逐&lt;/p>
&lt;/li>
&lt;li>
&lt;p>disjoint: 不相交的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>fraction: 分数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cascadinng: 级联&lt;/p>
&lt;/li>
&lt;li>
&lt;p>auxilinary: 辅助的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sink: 汇点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>discrepency: 差异&lt;/p>
&lt;/li>
&lt;li>
&lt;p>incoporate: 合并&lt;/p>
&lt;/li>
&lt;li>
&lt;p>converse: 相反的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sought: 寻找&lt;/p>
&lt;/li>
&lt;li>
&lt;p>polytope: 多面体&lt;/p>
&lt;/li>
&lt;li>
&lt;p>incident: 相邻的&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;Incident&amp;rdquo;：当我们说一条边和一个顶点是&amp;quot;incident&amp;quot;（相邻），意味着这条边的一个端点就是这个顶点。&lt;/li>
&lt;li>&amp;ldquo;Adjacent&amp;rdquo;：当我们说两个顶点是&amp;quot;adjacent&amp;quot;（邻接），意味着存在一条边连接这两个顶点。同样，当我们说两条边是&amp;quot;adjacent&amp;quot;（邻接），意味着这两条边共享一个公共顶点。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>feasible: 可行的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>polynomial: 多项式&lt;/p>
&lt;/li>
&lt;li>
&lt;p>comprise: 包括&lt;/p>
&lt;/li>
&lt;li>
&lt;p>logarithmic: 对数的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rounding: 四舍五入&lt;/p>
&lt;/li>
&lt;li>
&lt;p>infeasible: 不可行的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>unbounded: 无界的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>reciprocal: 倒数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>incremental: 增量的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>conservation: 保守&lt;/p>
&lt;/li>
&lt;li>
&lt;p>slackness: 松弛&lt;/p>
&lt;/li>
&lt;li>
&lt;p>conservation node: 保守节点, a node that has the same flow in and out&lt;/p>
&lt;/li>
&lt;li>
&lt;p>residual graph: 残余图, a graph that represents the remaining capacity of each edge&lt;/p>
&lt;/li>
&lt;li>
&lt;p>augmenting path: 增广路径, a path from source to sink in the residual graph&lt;/p>
&lt;/li>
&lt;li>
&lt;p>feasible flow: 可行流, a flow that satisfies the capacity constraints and conservation constraints&lt;/p>
&lt;/li>
&lt;li>
&lt;p>perfect matching: 完美匹配, a matching that covers all the nodes&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bipartite graph: 二分图, a graph that can be divided into two sets such that all edges are between the two sets&lt;/p>
&lt;/li>
&lt;li>
&lt;p>disjoint paths: 不相交路径, paths that do not share any nodes&lt;/p>
&lt;/li>
&lt;li>
&lt;p>vertex cover: 顶点覆盖, a set of vertices that covers all the edges&lt;/p>
&lt;/li>
&lt;li>
&lt;p>maximal matching: 最大匹配, a matching that cannot be extended by adding another edge&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cardinality 基数，集合中元素的数量&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Game Theory</title><link>https://shyu216.github.io/aquamega/p/game-theory/</link><pubDate>Thu, 30 May 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/game-theory/</guid><description>&lt;ul>
&lt;li>
&lt;p>pure Strategy: single action&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mixed Strategy: probability distribution over actions&lt;/p>
&lt;/li>
&lt;li>
&lt;p>weakly dominate: $\leq$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>strongly dominate: $&amp;lt;$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>a weakly(strictly) dominant strategy: always better than any other strategy&lt;/p>
&lt;/li>
&lt;li>
&lt;p>nash equilibrium: 每个agent都选了最优策略，其他agent不会改变策略&lt;/p>
&lt;/li>
&lt;li>
&lt;p>indifference: 通过调整我的策略概率，改变对手的收益（payoff）期望，使无论对手如何选择，他的满意度（utility）都一样&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="utility-function">Utility Function
&lt;/h2>&lt;p>U_i(a): what can agent i get from action a&lt;/p>
&lt;h2 id="normal-form-game">Normal Form Game
&lt;/h2>&lt;p>一轮，不知道对手的策略，只知道对手的utility function&lt;/p>
&lt;h2 id="extensive-form-game-广义形式博弈">Extensive Form Game 广义形式博弈
&lt;/h2>&lt;p>轮流决策，所以知道对手的策略&lt;/p>
&lt;h2 id="subgame-perfect-equilibrium-子博弈完美均衡">Subgame Perfect Equilibrium 子博弈完美均衡
&lt;/h2>&lt;p>当前玩家在他的回合的最优策略，对手在他的回合的最优策略。。。&lt;/p>
&lt;h2 id="backward-induction-反向归纳">Backward Induction 反向归纳
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">输入：广义形式博弈 G = (N, Agt, S, s_0, A, T, r)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">输出：每个状态 s ∈ S 的子博弈均衡
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">函数 BackwardInduction(s ∈ S):
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 如果 A(s) = ∅，则返回 r(s)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> best_child ← (-∞, ..., -∞)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 对于每个 a ∈ A(s)：
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> s&amp;#39; ← T(s,a)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> child_reward ← BackwardInduction(s&amp;#39;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 如果 child_reward(P(s)) &amp;gt; best_child(P(s))，则 best_child ← child_reward
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 返回 best_child
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">返回 BackwardInduction(s_0)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="multi-agent-q-learning">Multi-agent Q-learning
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">输入：随机博弈 G = (S, s_0, A^1, ..., A^n, r^1, ..., r^n, Agt, P, γ)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">输出：Q函数 Q^j，其中 j 是 self agent
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">初始化 Q^j 任意，例如，对于所有的状态 s 和联合动作 a，Q^j(s,a)=0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">重复：
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> s ← episode e 的第一个状态
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 重复（对于 episode e 的每一步）：
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 选择在 s 中应用的动作 a^j
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 例如，使用 Q^j 和一个多臂老虎机算法，如 ε-greedy
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 在状态 s 中执行动作 a^j
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 观察奖励 r^j 和新状态 s&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Q^j(s,a) ← Q^j(s,a) + α * [r^j + γ * max_a&amp;#39; Q^j(s&amp;#39;,a&amp;#39;) - Q^j(s,a)]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> s ← s&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 直到 episode e 结束（一个终止状态）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">直到 Q 收敛
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Greedy Relaxed Planning</title><link>https://shyu216.github.io/aquamega/p/greedy-relaxed-planning/</link><pubDate>Wed, 29 May 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/greedy-relaxed-planning/</guid><description>&lt;ul>
&lt;li>
&lt;p>h*: the optimal heuristic&lt;/p>
&lt;/li>
&lt;li>
&lt;p>h pre&amp;amp;del: the heuristic ignoring preconditions and delete effects, adimissible and consistent, &amp;ldquo;subset sum&amp;rdquo; problem, NP-hard&lt;/p>
&lt;/li>
&lt;li>
&lt;p>h goal_count: the number of goals not yet achieved, neither admissible nor consistent&lt;/p>
&lt;/li>
&lt;li>
&lt;p>h+/h del: admitssible and consistent, 相当于MST, 每个state只访问一遍，也NP-hard&lt;/p>
&lt;/li>
&lt;li>
&lt;p>h add: easily not admissible&lt;/p>
&lt;/li>
&lt;li>
&lt;p>h max: easily too small&lt;/p>
&lt;/li>
&lt;li>
&lt;p>h ff: use h add and h max&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Removing preconditions and delete effects is efficiently constructive but not computable。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>h max和h add的table是不一样的，一个是最大值，一个是累加值。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="delete-relaxation">Delete Relaxation
&lt;/h2>&lt;p>忽略搜索中所有的delete效果，在发现goal之前减少重复的状态。&lt;/p>
&lt;ul>
&lt;li>State Dominance: 如果一个状态支配另一个状态，那么我们可以忽略支配状态。被包含了。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">greedyRelaxedPlan&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">problem&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">candidate_pq&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">util&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">PriorityQueue&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">init_state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getStartState&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">init_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">candidate_pq&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">init_state&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">init_path&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">viewed&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">candidate_pq&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">state&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">candidate_pq&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">isGoalState&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">path&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">state&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">viewed&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">viewed&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">child_state&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">child_action&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">_&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getSuccessors&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># ignore cost as we are blind&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">child_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">path&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">child_action&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">candidate_pq&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">child_state&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">child_path&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Neither admissible nor consistent. 因为不保证optimal，只保证能找到解决方案。&lt;/p>
&lt;p>Optimal的都NP-hard。&lt;/p>
&lt;h2 id="additive-and-max-heuristics">Additive and Max Heuristics
&lt;/h2>&lt;ul>
&lt;li>Additive: 相加子目标的启发式，明显不是admissible。&lt;/li>
&lt;/ul>
&lt;p>$h^{add}(s, g) =
\begin{cases}
0 &amp;amp; \text{if } g \subseteq s \
\min_{a \in A, g \in add_a} (c(a) + h^{add}(s, pre_a)) &amp;amp; \text{if } |g| = 1 \
\sum_{g&amp;rsquo; \in g} h^{add}(s, {g&amp;rsquo;}) &amp;amp; \text{if } |g| &amp;gt; 1
\end{cases}$&lt;/p>
&lt;ul>
&lt;li>Max: 选择子目标中最大的启发式。最难解决的子节点。&lt;/li>
&lt;/ul>
&lt;p>$h^{max}(s, g) =
\begin{cases}
0 &amp;amp; \text{if } g \subseteq s \
\max_{a \in A, g \in add_a} (c(a) + h^{max}(s, pre_a)) &amp;amp; \text{if } |g| = 1 \
\max_{g&amp;rsquo; \in g} h^{max}(s, {g&amp;rsquo;}) &amp;amp; \text{if } |g| &amp;gt; 1
\end{cases}$&lt;/p>
&lt;p>都goal-aware，因为h+ ∞时，h也是∞。&lt;/p>
&lt;h2 id="best-supporter-heuristic">Best Supporter Heuristic
&lt;/h2>&lt;p>$bs_{s}^{max}(p) = argmin_{a\in A,p \in add_a}c(a)+h^{max}(s,pre_a)$&lt;br>
$bs_{s}^{add}(p) = argmin_{a\in A,p \in add_a}c(a)+h^{add}(s,pre_a)$&lt;/p>
&lt;ul>
&lt;li>
&lt;p>把$h_{add}$和$h_{max}$结合起来，选择最好的支持者。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>argmin: 在一系列动作里，选最小的h。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="bellman-ford-for-hmax-and-hadd">Bellman-Ford for hmax and hadd
&lt;/h2>&lt;p>Bellman-Ford variant computing hadd for state s&lt;/p>
&lt;p>反复更新表Tadd，直到表中的值不再改变。在每次迭代中，对于每个目标状态g，都会计算一个新的值fi(g)，这个值是当前状态s到状态g的最短路径的估计值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">bellmanFordHadd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">problem&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">states&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getStates&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">actions&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getActions&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getTransitionProbabilities&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">r&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getRewards&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">gamma&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getDiscount&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">theta&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.01&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Tadd&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">s&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">states&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">delta&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">s&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">states&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">v&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Tadd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Tadd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">min&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="nb">sum&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">s_prime&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">gamma&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">Tadd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s_prime&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">s_prime&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">states&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">actions&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">delta&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">delta&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">Tadd&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">]))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">delta&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">theta&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">Tadd&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="iterated-width">Iterated Width
&lt;/h2>&lt;p>Novelty：只考虑$w(s)$个状态变量atoms的变化情况。&lt;/p>
&lt;p>搜索直到目标状态的状态变量的数量。&lt;/p>
&lt;p>一个state的novelty：第一次出现的atom组合中的atom数量。the size of the smallest subset of atoms in s，that is true for the first time in search。&lt;/p></description></item><item><title>UCB and Greedy BFS</title><link>https://shyu216.github.io/aquamega/p/ucb-and-greedy-bfs/</link><pubDate>Wed, 29 May 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/ucb-and-greedy-bfs/</guid><description>&lt;h2 id="uniform-cost-search">Uniform Cost Search
&lt;/h2>&lt;p>Priority Queue，最先被探索离起始节点最近（即路径成本最低）的节点。&lt;/p>
&lt;p>Breath First Search属于Uniform Cost Search的特例，即每个节点的路径成本都是1。&lt;/p>
&lt;p>UCS只看到了路径成本，没有考虑启发式。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">uniformCostSearch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">problem&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">candidate_pq&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">util&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">PriorityQueue&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">init_state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getStartState&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">init_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">candidate_pq&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">init_state&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">init_path&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">viewed&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">candidate_pq&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">state&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">candidate_pq&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">isGoalState&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">path&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">state&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">viewed&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">viewed&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">child_state&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">child_action&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">child_cost&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getSuccessors&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">child_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">path&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">child_action&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">candidate_pq&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">child_state&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">child_path&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getCostOfActions&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">child_path&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="greedy-best-first-search">Greedy Best First Search
&lt;/h2>&lt;p>BFS只看到了启发式，没有考虑路径成本。&lt;/p>
&lt;p>If h=0，BFS是什么根据它的Priority Queue的实现。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">bestFirstSearch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">problem&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">heuristic&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">nullHeuristic&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">candidate_pq&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">util&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">PriorityQueue&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">init_state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getStartState&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">init_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">candidate_pq&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">init_state&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">init_path&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="n">heuristic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">init_state&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">viewed&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">candidate_pq&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">state&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">candidate_pq&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">isGoalState&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">path&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">state&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">viewed&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">viewed&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">child_state&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">child_action&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">_&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getSuccessors&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># ignore cost as we are blind&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">child_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">path&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">child_action&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">candidate_pq&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">child_state&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">child_path&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="n">heuristic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">child_state&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>A* and Hill Climbing</title><link>https://shyu216.github.io/aquamega/p/a-and-hill-climbing/</link><pubDate>Thu, 02 May 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/a-and-hill-climbing/</guid><description>&lt;h2 id="a算法带有重复检测和重新打开">A*算法（带有重复检测和重新打开）
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">设 open 为新的优先级队列，按照 g(state(σ)) + h(state(σ)) 升序排列
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">open.insert(make-root-node(init()))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">设 closed 为空集
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">设 best-g 为空集 /* 将状态映射到数字 */
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">当 open 不为空时：
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> σ := open.pop-min()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 如果 state(σ) 不在 closed 中或 g(σ) &amp;lt; best-g(state(σ))：
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> /* 如果 g 更好则重新打开；注意所有具有相同状态但 g 较差的 σ′ 都在 open 中位于 σ 后面，并且在轮到它们时将被跳过 */
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> closed := closed ∪{state(σ)}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> best-g(state(σ)) := g(σ)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 如果 is-goal(state(σ))：返回 extract-solution(σ)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 对于每个 (a,s′) ∈succ(state(σ))：
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> σ′ := make-node(σ,a,s′)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 如果 h(state(σ′)) &amp;lt; ∞：open.insert(σ′)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">返回 unsolvable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">aStarSearch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">problem&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">heuristic&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">nullHeuristic&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;Search the node that has the lowest combined cost and heuristic first.&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">myPQ&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">util&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">PriorityQueue&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">startState&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getStartState&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">startNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">startState&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">myPQ&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">startNode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">heuristic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">startState&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">best_g&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">dict&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">myPQ&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">myPQ&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">state&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">cost&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="ow">not&lt;/span> &lt;span class="n">state&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">best_g&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">or&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">cost&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">best_g&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">]):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">best_g&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cost&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">isGoalState&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">path&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">succ&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getSuccessors&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">succState&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">succAction&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">succCost&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">succ&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">new_cost&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cost&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">succCost&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">newNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">succState&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">new_cost&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">path&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">succAction&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">myPQ&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">newNode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">heuristic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">succState&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">new_cost&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">None&lt;/span> &lt;span class="c1"># Goal not found&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>If h=0, A* is equivalent to Uniform Cost Search.&lt;/p>
&lt;p>If h admissible, A* is optimal. 因为我们的h比最优h小，在达到最优h之前，我们已经尝试过这个状态。&lt;/p>
&lt;h2 id="weighted-a算法">Weighted A*算法
&lt;/h2>&lt;p>给heuristic函数加权，以调整搜索的速度。&lt;/p>
&lt;p>w越大，搜索越快，但可能会错过最优解，w越小，搜索越慢，但更有可能找到最优解。&lt;/p>
&lt;p>w=0时，等价于Uniform Cost Search。&lt;/p>
&lt;p>w to ∞时，等价于Greedy Best First Search。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">weightedAStarSearch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">problem&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">heuristic&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">nullHeuristic&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">weight&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;Search the node that has the lowest combined cost and heuristic first.&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">myPQ&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">util&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">PriorityQueue&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">startState&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getStartState&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">startNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">startState&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">myPQ&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">startNode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">weight&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">heuristic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">startState&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">best_g&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">dict&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">myPQ&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">myPQ&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">state&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">cost&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="ow">not&lt;/span> &lt;span class="n">state&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">best_g&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">or&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">cost&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">best_g&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">]):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">best_g&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cost&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">isGoalState&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">path&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">succ&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getSuccessors&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">succState&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">succAction&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">succCost&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">succ&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">new_cost&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cost&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">succCost&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">newNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">succState&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">new_cost&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">path&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">succAction&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">myPQ&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">newNode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">weight&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">heuristic&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">succState&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">new_cost&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">None&lt;/span> &lt;span class="c1"># Goal not found&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="爬山算法">爬山算法
&lt;/h2>&lt;p>local最优。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">σ := make-root-node(init())
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">永远执行以下操作：
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 如果 is-goal(state(σ))：
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 返回 extract-solution(σ)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Σ′ := {make-node(σ,a,s′) |(a,s′) ∈succ(state(σ)) }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> σ := 选择 Σ′ 中 h 值最小的元素 /* （随机打破平局） */
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>BFS and DFS</title><link>https://shyu216.github.io/aquamega/p/bfs-and-dfs/</link><pubDate>Thu, 02 May 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/bfs-and-dfs/</guid><description>&lt;h2 id="广度优先搜索bfs">广度优先搜索（BFS）
&lt;/h2>&lt;p>队列，先进先出，后进后出。&lt;/p>
&lt;p>Optimal when costs are uniform&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">breadthFirstSearch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">problem&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">candidate_queue&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">util&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Queue&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">init_state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getStartState&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">init_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">candidate_queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">init_state&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">init_path&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">viewed&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">candidate_queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">state&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">candidate_queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">isGoalState&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">path&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">state&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">viewed&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">viewed&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">child_state&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">child_action&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">_&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getSuccessors&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># ignore cost as we are blind&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">child_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">path&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">child_action&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">candidate_queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">child_state&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">child_path&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="深度优先搜索dfs">深度优先搜索（DFS）
&lt;/h2>&lt;p>栈，先进后出，后进先出。&lt;/p>
&lt;p>搜索空间可能无限大（无限深）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">depthFirstSearch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">problem&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">candidate_stack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">util&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Stack&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">init_state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getStartState&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">init_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">candidate_stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">init_state&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">init_path&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">viewed&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">candidate_stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">state&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">candidate_stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">isGoalState&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">path&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">state&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">viewed&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">viewed&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">child_state&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">child_action&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">_&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">problem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getSuccessors&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># ignore cost as we are blind&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">child_path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">path&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">child_action&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">candidate_stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">child_state&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">child_path&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>MDPs</title><link>https://shyu216.github.io/aquamega/p/mdps/</link><pubDate>Thu, 02 May 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/mdps/</guid><description>&lt;h2 id="markov-decision-processesmdps马尔可夫决策过程">Markov Decision Processes（MDPs）马尔可夫决策过程
&lt;/h2>&lt;p>MDP是完全可观察的，概率状态模型：&lt;/p>
&lt;p>状态空间 $S$ &lt;br>
初始状态 $s_0 \in S$ &lt;br>
一组目标状态 $G \subseteq S$ &lt;br>
在每个状态 $s \in S$ 中可应用的动作 $A(s) \subseteq A$ &lt;br>
对于 $s \in S$ 和 $a \in A(s)$，有转移概率 $P_a(s&amp;rsquo;|s)$ &lt;br>
动作成本 $c(a,s) &amp;gt; 0$&lt;/p>
&lt;p>其中：&lt;br>
解决方案是将状态映射到动作的函数（策略）&lt;br>
最优解最小化预期的前往目标的成本&lt;/p>
&lt;h2 id="partially-observable-mdps-pomdps-部分可观察的马尔可夫决策过程">Partially Observable MDPs (POMDPs) 部分可观察的马尔可夫决策过程
&lt;/h2>&lt;p>POMDP是部分可观察的，概率状态模型：&lt;/p>
&lt;p>状态 $s \in S$ &lt;br>
在每个状态 $s \in S$ 中可应用的动作 $A(s) \subseteq A$ &lt;br>
对于 $s \in S$ 和 $a \in A(s)$，有转移概率 $P_a(s&amp;rsquo;|s)$ &lt;br>
初始信念状态 $b_0$ &lt;br>
最终信念状态 $b_f$ &lt;br>
由概率 $P_a(o|s)$，$o \in Obs$ 给出的传感器模型&lt;/p>
&lt;p>其中：&lt;br>
信念状态是关于 $S$ 的概率分布 &lt;br>
解决方案是将信念状态映射到动作的策略 &lt;br>
最优策略最小化从 $b_0$ 到 $G$ 的预期成本&lt;/p>
&lt;p>&lt;em>see also&lt;/em>: &lt;a class="link" href="https://gibberblot.github.io/rl-notes/single-agent/MDPs.html" target="_blank" rel="noopener"
>https://gibberblot.github.io/rl-notes/single-agent/MDPs.html&lt;/a>&lt;/p>
&lt;h2 id="value-iteration">Value Iteration
&lt;/h2>&lt;p>一种动态规划算法，用于计算MDP的最优策略。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">value_iteration&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">states&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">actions&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">P&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">gamma&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">theta&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">s&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">states&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="c1"># Initialize value function&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">delta&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">s&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">states&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">v&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">V&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">s_prime&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">s_prime&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">gamma&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">V&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s_prime&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">s_prime&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">states&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">actions&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">delta&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">delta&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">V&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">]))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">delta&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">theta&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1"># Check for convergence&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">V&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="bellman-optimality-equation">Bellman Optimality Equation
&lt;/h3>&lt;p>$
V^*(s) = \max_{a \in A(s)} \sum_{s&amp;rsquo;} P_a(s&amp;rsquo;|s) \left[ R_a(s&amp;rsquo;|s) + \gamma V^{*}{(s&amp;rsquo;)} \right]
$&lt;/p>
&lt;ul>
&lt;li>所有可能的下一个状态的概率&lt;/li>
&lt;li>动作的奖励&lt;/li>
&lt;li>下一个状态的价值 x 折扣，前一个iteration存储的价值&lt;/li>
&lt;/ul>
&lt;h3 id="q-value">Q-Value
&lt;/h3>&lt;p>对于每个状态 $s \in S$，其一个可能动作 $a \in A(s)$ 的质量是：&lt;br>
$
Q(s,a) = \sum_{s&amp;rsquo;} P_a(s&amp;rsquo;|s) \left[ R_a(s&amp;rsquo;|s) + \gamma V^*(s&amp;rsquo;) \right]
$&lt;/p>
&lt;p>其中 $\gamma$ 是折扣，越接近1，越重视长期奖励，越接近0，越重视短期奖励。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">0.95, 0.9025, 0.857375, 0.81450625...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0.9, 0.81, 0.729, 0.6561...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0.8, 0.64, 0.512, 0.4096...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0.7, 0.49, 0.343, 0.2401...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="policy">Policy
&lt;/h3>&lt;p>$\pi(s) = arg max Q(s,a)$&lt;/p>
&lt;h2 id="multi-armed-bandit">Multi-Armed Bandit
&lt;/h2>&lt;p>平行地尝试多个动作，平衡exploitation和exploration。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>minimising regret，没有选择最佳动作的损失&lt;/p>
&lt;p>&lt;strong>输入&lt;/strong>: 多臂老虎机问题 $M = {X_{i,k}, A, T}$ &lt;br>
&lt;strong>输出&lt;/strong>: Q函数 $Q$ &lt;br>
初始化 $Q$ 为任意值; 例如，对所有的臂 $a$，$Q(a) \leftarrow 0$ &lt;br>
初始化 $N$ 为任意值; 例如，对所有的臂 $a$，$N(a) \leftarrow 0$ &lt;br>
$k \leftarrow 1$ &lt;br>
&lt;strong>while&lt;/strong> $k \leq T$ &lt;strong>do&lt;/strong>&lt;br>
$\quad$ $a \leftarrow$ 在第 $k$ 轮选择一个臂&lt;br>
$\quad$ 在第 $k$ 轮执行臂 $a$ 并观察奖励 $X_{a,k}$&lt;br>
$\quad$ $N(a) \leftarrow N(a) + 1$&lt;br>
$\quad$ $Q(a) \leftarrow Q(a) + \frac{1}{N(a)} [X_{a,k} - Q(a)]$&lt;br>
$\quad$ $k \leftarrow k + 1$&lt;br>
&lt;strong>end while&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$\epsilon$-greedy，以 $1-\epsilon$ 的概率选择最佳动作，以 $\epsilon$ 的概率选择随机动作&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$\epsilon$-greedy with decay，随着时间的推移，减少 $\epsilon$ 的值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>UCB&lt;/p>
&lt;p>$\text{argmax}_{a}\left(Q(a) + \sqrt{\frac{2 \ln t}{N(a)}}\right)$&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="q-learning">Q-Learning
&lt;/h2>&lt;p>&lt;strong>Input&lt;/strong>: MDP $M = \langle S, s_0, A, P_a(s&amp;rsquo; | s), r(s, a, s&amp;rsquo;) \rangle$ &lt;br>
&lt;strong>Output&lt;/strong>: Q-function $Q$ &lt;br>
Initialise $Q$ arbitrarily; e.g., $Q(s, a) \leftarrow 0$ for all $s$ and $a$ &lt;br>
&lt;strong>repeat&lt;/strong>&lt;br>
$\quad$ $s \leftarrow$ the first state in episode $e$&lt;br>
$\quad$ &lt;strong>repeat&lt;/strong> (for each step in episode $e$)&lt;br>
$\quad\quad$ Select action $a$ to apply in $s$; e.g. using $Q$ and a multi-armed bandit algorithm such as $\epsilon$-greedy&lt;br>
$\quad\quad$ Execute action $a$ in state $s$&lt;br>
$\quad\quad$ Observe reward $r$ and new state $s&amp;rsquo;$&lt;br>
$\quad\quad$ $\delta \leftarrow r + \gamma \cdot \max_{a&amp;rsquo;} Q(s&amp;rsquo;, a&amp;rsquo;) - Q(s, a)$&lt;br>
$\quad\quad$ $Q(s, a) \leftarrow Q(s, a) + \alpha \cdot \delta$&lt;br>
$\quad\quad$ $s \leftarrow s&amp;rsquo;$&lt;br>
$\quad$ &lt;strong>until&lt;/strong> $s$ is the last state of episode $e$ (a terminal state)&lt;br>
&lt;strong>until&lt;/strong> $Q$ converges&lt;/p>
&lt;ul>
&lt;li>$max_{a&amp;rsquo;} Q(s&amp;rsquo;, a&amp;rsquo;)$ 也可以写成 $V(s&amp;rsquo;)$，即下一个状态的价值&lt;/li>
&lt;/ul>
&lt;h2 id="sarsa">SARSA
&lt;/h2>&lt;p>&lt;strong>Input&lt;/strong>: MDP $M = \langle S, s_0, A, P_a(s&amp;rsquo; | s), r(s, a, s&amp;rsquo;) \rangle$ &lt;br>
&lt;strong>Output&lt;/strong>: Q-function $Q$ &lt;br>
Initialise $Q$ arbitrarily; e.g., $Q(s, a) \leftarrow 0$ for all $s$ and $a$ &lt;br>
&lt;strong>repeat&lt;/strong>&lt;br>
$\quad$ $s \leftarrow$ the first state in episode $e$&lt;br>
$\quad$ Choose $a$ from $s$ using policy derived from $Q$ (e.g., $\epsilon$-greedy)&lt;br>
$\quad$ &lt;strong>repeat&lt;/strong> (for each step in episode $e$)&lt;br>
$\quad\quad$ Take action $a$, observe $r$, $s&amp;rsquo;$&lt;br>
$\quad\quad$ Choose $a&amp;rsquo;$ from $s&amp;rsquo;$ using policy derived from $Q$ (e.g., $\epsilon$-greedy)&lt;br>
$\quad\quad$ $\delta \leftarrow r + \gamma \cdot Q(s&amp;rsquo;, a&amp;rsquo;) - Q(s, a)$&lt;br>
$\quad\quad$ $Q(s, a) \leftarrow Q(s, a) + \alpha \cdot \delta$&lt;br>
$\quad\quad$ $s \leftarrow s&amp;rsquo;$, $a \leftarrow a&amp;rsquo;$&lt;br>
$\quad$ &lt;strong>until&lt;/strong> $s$ is the last state of episode $e$ (a terminal state)&lt;br>
&lt;strong>until&lt;/strong> $Q$ converges&lt;/p>
&lt;ul>
&lt;li>Q-Learning是off-policy，因为on当前策略下的Q值，对当前策略更乐观&lt;/li>
&lt;li>SARSA是on-policy，所以off了当前策略下的Q值，更保守&lt;/li>
&lt;/ul>
&lt;h2 id="n-step-reinforcement-learning">n-step reinforcement learning
&lt;/h2>&lt;p>记账，在n-step后再一起更新Q值。&lt;/p>
&lt;h2 id="mcts">MCTS
&lt;/h2>&lt;ul>
&lt;li>Selection：选择一个节点，直到找到一个未扩展的节点&lt;/li>
&lt;li>Expansion：扩展一个未扩展的节点&lt;/li>
&lt;li>Simulation：模拟一个随机游戏，直到结束&lt;/li>
&lt;li>Backpropagation：更新所有访问的节点的值&lt;/li>
&lt;/ul>
&lt;p>offline：完成所有模拟后再选择最佳动作&lt;/p>
&lt;p>online：每次模拟后选择最佳动作，继续对新的节点进行模拟。在下次选择时，同时也利用了之前的模拟结果，MCTS是online的。&lt;/p>
&lt;p>用平均值更新：新Q = 旧Q + 学习率 * 误差，实际上就是平均值&lt;/p>
&lt;h2 id="uct">UCT
&lt;/h2>&lt;p>用UCB来select。&lt;/p>
&lt;p>$\text{argmax}_{a \in A(s)} Q(s,a) + 2 C_p \sqrt{\frac{2 \ln N(s)}{N(s,a)}}$ &lt;br>
where $C_p$ 自己选，看是更偏向exploration还是exploitation&lt;/p>
&lt;h2 id="linear-q-functionn-approximation">Linear Q-functionn Approximation
&lt;/h2>&lt;p>## features = ## states * ## actions&lt;/p>
&lt;p>$Q(s,a) = f^T w = \sum_{i=1}^{n} f_i(s,a) w_i$&lt;/p>
&lt;h3 id="update">Update
&lt;/h3>&lt;p>$w \leftarrow w + \alpha \delta f(s,a)$ &lt;br>
where &lt;br>
$\delta = r + \gamma \max_{a&amp;rsquo;} Q(s&amp;rsquo;,a&amp;rsquo;) - Q(s,a)$ if Q-learning &lt;br>
$\delta = r + \gamma Q(s&amp;rsquo;,a&amp;rsquo;) - Q(s,a)$ if SARSA&lt;/p>
&lt;h2 id="shaped-reward">Shaped Reward
&lt;/h2>&lt;p>$Q(s,a) \leftarrow Q(s,a) + \alpha [r + \underbrace{F(s,s&amp;rsquo;)}&lt;em>{\text{additional reward}} + \gamma \max&lt;/em>{a&amp;rsquo;} Q(s&amp;rsquo;,a&amp;rsquo;) - Q(s,a)]$&lt;/p>
&lt;h3 id="potential-based-reward-shaping">Potential-based Reward Shaping
&lt;/h3>&lt;p>$F(s,s&amp;rsquo;) = \gamma \Phi(s&amp;rsquo;) - \Phi(s)$&lt;/p>
&lt;p>For example, in Gridworld, &lt;br>
$\Phi(s) = 1 - \frac{|x(g) - x(s)| + |y(g) - y(s)|}{width + height - 2}$&lt;/p>
&lt;h2 id="policy-iteration">Policy Iteration
&lt;/h2>&lt;p>魔改bellman方程，将所有动作可能性替换成当前策略下的动作。&lt;/p></description></item></channel></rss>