<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Analysis on Dale的水硕日记</title><link>https://shyu216.github.io/aquamega/tags/analysis/</link><description>Recent content in Analysis on Dale的水硕日记</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 11 Jun 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://shyu216.github.io/aquamega/tags/analysis/index.xml" rel="self" type="application/rss+xml"/><item><title>Admortized Analysis</title><link>https://shyu216.github.io/aquamega/p/admortized-analysis/</link><pubDate>Tue, 11 Jun 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/admortized-analysis/</guid><description>&lt;p>$\sum_{i=1}^{m} cost(\sigma_i) \leq \sum_{i=1}^{m} a(\sigma_i)$&lt;/p>
&lt;p>摊还分析是一种分析数据结构操作成本的方法，它将操作的成本在一系列操作中进行平均，而不是单独考虑每个操作。&lt;/p>
&lt;p>我们的目标是证明对于任何一系列的动态数组操作 $\sigma_1,&amp;hellip;,\sigma_m$，如果每个操作的摊还成本 $a(\sigma_i)$ 是 $O(1)$（即常数时间），那么整体的成本不等式 $\sum_{i=1}^{m} cost(\sigma_i) \leq \sum_{i=1}^{m} a(\sigma_i)$ 就能成立。&lt;/p>
&lt;p>这个不等式的含义是，所有操作的实际总成本（左边的部分）不会超过所有操作的摊还总成本（右边的部分）。这是摊还分析的一个重要性质，它保证了我们的摊还成本确实反映了实际的成本。&lt;/p>
&lt;h2 id="prepaid">Prepaid
&lt;/h2>&lt;p>$\sum_{i=1}^{m} a(\sigma_i) = \sum_{i=1}^{m} cost(\sigma_i) + \sum_{i=1}^{m} \Beta$&lt;/p>
&lt;p>where $\Beta \geq 0$ (总是有余额)&lt;/p>
&lt;p>&amp;ldquo;Prepaid&amp;rdquo;（预付）是摊还分析中的一个概念，它描述的是一种策略，即在执行一些高成本的操作之前，先执行一些低成本的操作来“预付”高成本操作的部分或全部成本。&lt;/p>
&lt;p>例如，考虑一个动态数组的插入操作。当数组满时，我们需要分配一个新的、更大的数组，并将旧数组中的所有元素复制到新数组中。这个操作的成本是线性的。然而，如果我们将这个成本均摊到之前的每次插入操作上，那么每次插入操作的摊还成本就是常数的。这就是预付策略的一个例子：我们通过每次插入操作“预付”一部分成本，来避免在数组满时一次性支付所有的成本。&lt;/p>
&lt;p>预付策略的一个关键思想是，我们可以将一些高成本的操作的成本分摊到多个低成本的操作上，从而使得所有操作的摊还成本都保持在一个可接受的范围内。这种策略在设计和分析高效的数据结构和算法时非常有用。&lt;/p>
&lt;h2 id="potential-function">Potential Function
&lt;/h2>&lt;p>$\sum_{i=1}^{m} a(\sigma_i) = \sum_{i=1}^{m} cost(\sigma_i) + \sum_{i=1}^{m} \Phi(D_i) - \Phi(D_0)$&lt;/p>
&lt;p>where $\Phi(D_0)$ = 0, $\Phi(D_i) \geq 0$（不能超出势能）&lt;/p>
&lt;p>在摊还分析中，我们经常使用势能方法来证明摊还成本。下面是一个经典的例子：动态数组的插入操作。&lt;/p>
&lt;p>动态数组是一种可以动态增长和缩小的数组。当我们向动态数组中插入元素时，如果数组已满，我们需要创建一个新的、更大的数组，然后将旧数组中的所有元素复制到新数组中。这个操作的成本是线性的。然而，如果我们使用摊还分析，我们可以证明每次插入操作的摊还成本是常数的。&lt;/p>
&lt;p>我们定义势能函数 $\Phi$ 为数组的当前大小减去数组中的元素数量。当我们插入一个元素时，有两种情况：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>如果数组没有满，我们只需要在数组的末尾添加一个元素。这个操作的实际成本是 $1$，势能的变化是 $-1$，所以摊还成本是 $1 - (-1) = 2$。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果数组已满，我们需要创建一个新的、大小为 $2n$ 的数组，并将 $n$ 个元素复制到新数组中。这个操作的实际成本是 $n+1$，势能的变化是 $n - n = 0$，所以摊还成本是 $n+1 - 0 = n+1$。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>在第二种情况中，摊还成本看起来是线性的。然而，这种情况只会发生在插入操作的数量是当前数组大小的整数倍时。在大多数情况下，我们处于第一种情况，摊还成本是常数的。因此，我们可以说插入操作的摊还成本是常数的，即 $a(\sigma_i) \in O(1)$。&lt;/p></description></item><item><title>log n，n，2^n的关系</title><link>https://shyu216.github.io/aquamega/p/log-nn2n%E7%9A%84%E5%85%B3%E7%B3%BB/</link><pubDate>Tue, 11 Jun 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/log-nn2n%E7%9A%84%E5%85%B3%E7%B3%BB/</guid><description>&lt;h2 id="big-o-notation">Big-O Notation
&lt;/h2>&lt;p>$$ f(n) \in O(g(n)) \text{ iff } \exists c_1, c_2, \forall n &amp;gt; c_2, f(n) \leq c_1 \cdot g(n)$$&lt;/p>
&lt;h2 id="olog-n-subset-onk-subset-o2n">$O(\log n) \subset O(n^k) \subset O(2^n)$
&lt;/h2>&lt;p>求证？设新方程，用相除或相减把不等式移到同一边，然后证明单调性，且大于1或大于0，取得$c_1, c_2$的值。&lt;/p></description></item></channel></rss>