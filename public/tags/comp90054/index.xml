<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Comp90054 on Aqua Mega</title>
    <link>http://localhost:1313/aquamega/tags/comp90054/</link>
    <description>Recent content in Comp90054 on Aqua Mega</description>
    <image>
      <title>Aqua Mega</title>
      <url>https://github.com/shyu216.png</url>
      <link>https://github.com/shyu216.png</link>
    </image>
    <generator>Hugo -- 0.125.4</generator>
    <language>en</language>
    <lastBuildDate>Thu, 02 May 2024 11:13:45 +1000</lastBuildDate>
    <atom:link href="http://localhost:1313/aquamega/tags/comp90054/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>A*</title>
      <link>http://localhost:1313/aquamega/pseudocode/astar/</link>
      <pubDate>Thu, 02 May 2024 11:13:45 +1000</pubDate>
      <guid>http://localhost:1313/aquamega/pseudocode/astar/</guid>
      <description>A*算法（带有重复检测和重新打开） 设 open 为新的优先级队列，按照 g(state(σ)) + h(state(σ)) 升序排列 open.insert(make-root-node(init())) 设 closed 为空集 设 best-g 为空集 /* 将状态映射到数字 */ 当 open 不为空时： σ := open.pop-min() 如果 state(σ) 不在 closed 中或 g(σ) &amp;lt; best-g(state(σ))： /* 如果 g 更好则重新打开；注意所有具有相同状态但 g 较差的 σ′ 都在 open 中位于 σ 后面，并且在轮到它们时将被跳过 */ closed := closed ∪{state(σ)} best-g(state(σ)) := g(σ) 如果 is-goal(state(σ))：返回 extract-solution(σ) 对于每个 (a,s′) ∈succ(state(σ))： σ′ := make-node(σ,a,s′) 如果 h(state(σ′)) &amp;lt; ∞：open.insert(σ′) 返回 unsolvable </description>
    </item>
    <item>
      <title>Hill Climbing</title>
      <link>http://localhost:1313/aquamega/pseudocode/hill_climbing/</link>
      <pubDate>Thu, 02 May 2024 11:13:45 +1000</pubDate>
      <guid>http://localhost:1313/aquamega/pseudocode/hill_climbing/</guid>
      <description>爬山算法 σ := make-root-node(init()) 永远执行以下操作： 如果 is-goal(state(σ))： 返回 extract-solution(σ) Σ′ := {make-node(σ,a,s′) |(a,s′) ∈succ(state(σ)) } σ := 选择 Σ′ 中 h 值最小的元素 /* （随机打破平局） */ </description>
    </item>
    <item>
      <title>MDPs</title>
      <link>http://localhost:1313/aquamega/pseudocode/mdps/</link>
      <pubDate>Thu, 02 May 2024 11:13:45 +1000</pubDate>
      <guid>http://localhost:1313/aquamega/pseudocode/mdps/</guid>
      <description>Markov Decision Processes（MDPs）马尔可夫决策过程 MDP是完全可观察的，概率状态模型：
状态空间 $S$
初始状态 $s_0 \in S$
一组目标状态 $G \subseteq S$
在每个状态 $s \in S$ 中可应用的动作 $A(s) \subseteq A$
对于 $s \in S$ 和 $a \in A(s)$，有转移概率 $P_a(s&#39;|s)$
动作成本 $c(a,s) &gt; 0$
解决方案是将状态映射到动作的函数（策略）
最优解最小化预期的前往目标的成本
Partially Observable MDPs (POMDPs) 部分可观察的马尔可夫决策过程 POMDP是部分可观察的，概率状态模型：
状态 $s \in S$
在每个状态 $s \in S$ 中可应用的动作 $A(s) \subseteq A$
对于 $s \in S$ 和 $a \in A(s)$，有转移概率 $P_a(s&#39;|s)$
初始信念状态 $b_0$
最终信念状态 $b_f$
由概率 $P_a(o|s)$，$o \in Obs$ 给出的传感器模型</description>
    </item>
    <item>
      <title>Comp90054</title>
      <link>http://localhost:1313/aquamega/course/comp90054/</link>
      <pubDate>Fri, 26 Apr 2024 14:55:43 +1000</pubDate>
      <guid>http://localhost:1313/aquamega/course/comp90054/</guid>
      <description>AI Planning for Autonomy classical planning (blind/heuristic): https://fai.cs.uni-saarland.de/hoffmann/papers/ki11.pdf PDDL relaxation reinforcement learning: https://gibberblot.github.io/rl-notes/index.html Vocabs Nondeterministic Polynomial: 不确定多项式，没有已知的多项式时间算法可以在所有情况下找到一个解
定义（安全/目标感知/可接受/一致性）。假设$\Pi$是一个计划任务，具有状态空间$\Theta_{\Pi} = (S, L, c, T, I, G)$，并且$h$是$\Pi$的一个启发式。如果启发式满足以下条件，那么它被称为：
安全（Safe）：如果对于所有$h(s) = \infty$的状态$s \in S$，都有$h^*(s) = \infty$，则启发式被称为安全。
目标感知（Goal-aware）：如果对于所有目标状态$s \in S_G$，都有$h(s) = 0$，则启发式被称为目标感知。
可接受（Admissible）：如果对于所有状态$s \in S$，都有$h(s) \leq h^*(s)$，则启发式被称为可接受。
一致（Consistent）：如果对于所有$s \xrightarrow{a} s&#39;$的转移，都有$h(s) \leq h(s&#39;) + c(a)$，则启发式被称为一致。
关系： 命题：假设$\Pi$是一个计划任务，具有状态空间$\Theta_{\Pi} = (S, L, c, T, I, S_G)$，并且$h$是$\Pi$的一个启发式。如果$h$是一致的和目标感知的，则$h$是可接受的。如果$h$是可接受的，则$h$是目标感知的。如果$h$是可接受的，则$h$是安全的。没有其他这种形式的蕴含关系成立。
STRIPS: 问题是一个四元组$P = \langle F,O,I,G \rangle$：
$F$ fact, 原子, 变量
$O$ 或 $A$ operator, action, 操作符, 动作</description>
    </item>
  </channel>
</rss>
