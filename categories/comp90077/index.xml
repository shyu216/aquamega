<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>COMP90077 on Dale的水硕日记</title><link>https://shyu216.github.io/aquamega/categories/comp90077/</link><description>Recent content in COMP90077 on Dale的水硕日记</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 15 Jun 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://shyu216.github.io/aquamega/categories/comp90077/index.xml" rel="self" type="application/rss+xml"/><item><title>Linear Programming</title><link>https://shyu216.github.io/aquamega/p/linear-programming/</link><pubDate>Sat, 15 Jun 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/linear-programming/</guid><description>&lt;h2 id="linear-program">Linear Program
&lt;/h2>&lt;p>最大流问题可以被表述为一个线性规划问题。线性规划是一种优化问题，目标是在一组线性约束条件下最大化或最小化一个线性目标函数。&lt;/p>
&lt;p>对于最大流问题，我们可以定义以下的线性规划模型：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>变量：对于每条边 e，我们定义一个变量 f(e)，表示边 e 的流量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>目标函数：我们的目标是最大化从源点 s 到汇点 t 的总流量，即最大化 ∑f(e)，其中求和是对所有从 s 出发的边 e 进行的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>约束条件：我们有两种类型的约束条件：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>容量约束：对于每条边 e，我们有 f(e) ≤ c(e)，其中 c(e) 是边 e 的容量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>流量守恒约束：对于图中的每个非源非汇节点 v，我们有 ∑f(e_in) = ∑f(e_out)，其中 e_in 是进入节点 v 的边，e_out 是离开节点 v 的边。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>以下是对应的线性规划模型：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">maximize ∑f(e) for all e from s
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">subject to
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">f(e) ≤ c(e) for all e
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">∑f(e_in) = ∑f(e_out) for all v ≠ s, t
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">f(e) ≥ 0 for all e
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个模型可以使用各种线性规划算法来解决，例如单纯形法（Simplex Method）或内点法（Interior Point Method）。&lt;/p>
&lt;h2 id="vertex-cover">Vertex Cover
&lt;/h2>&lt;p>顶点覆盖（Vertex Cover）是图论中的一个重要概念。&lt;/p>
&lt;p>在一个图中，顶点覆盖是一个顶点的集合，这个集合的特性是图中的每一条边至少有一个端点在这个集合中。换句话说，如果你从这个集合中选出一个顶点，你可以覆盖到至少一条边。&lt;/p>
&lt;p>例如，考虑一个简单的图，它有四个顶点（A, B, C, D）和四条边（AB, BC, CD, DA）。在这个图中，{A, B, C, D} 是一个顶点覆盖，因为每一条边都至少有一个端点在这个集合中。同样，{A, C} 或者 {B, D} 也是顶点覆盖。&lt;/p>
&lt;p>顶点覆盖问题是寻找一个最小的顶点覆盖，也就是包含最少顶点的覆盖。这是一个 NP 完全问题，意味着没有已知的多项式时间算法可以解决所有的顶点覆盖问题。然而，有一些启发式算法和近似算法可以在实际中有效地解决顶点覆盖问题，例如贪心算法。&lt;/p>
&lt;h3 id="max-matching-for-factor-2-approximation">Max Matching for Factor 2 Approximation
&lt;/h3>&lt;p>最大匹配（Max Matching）是图论中的一个重要概念。在一个图中，一个匹配是一个边的集合，其中每个顶点最多与一条边相连。最大匹配是一个具有最大边数的匹配。&lt;/p>
&lt;p>一个简单的近似算法是找到一个最大匹配，然后将匹配中的每条边的两个端点都加入顶点覆盖。这个算法的解至多是最优解的两倍。&lt;/p>
&lt;p>这个算法的正确性可以通过以下两点来证明：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>它是一个覆盖：假设不是，那么存在一条没有被覆盖的边。但是，这条边应该被加入到最大匹配中，因为它不与当前匹配中的任何边共享端点。这就产生了矛盾，所以这个假设是错误的，这个集合确实是一个覆盖。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>它至多是最优解的两倍：因为每条匹配的边都贡献了两个顶点到覆盖中，所以覆盖的大小是匹配的大小的两倍。而最大匹配的大小至少是任何顶点覆盖的大小（因为每个覆盖的顶点至多可以覆盖一条匹配的边），所以这个覆盖的大小至多是最优覆盖的大小的两倍。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="lp-relaxation-for-vertex-cover">LP Relaxation for Vertex Cover
&lt;/h3>&lt;p>在线性规划版本的顶点覆盖问题中，我们的目标是找到一组𝑦𝑣的值（对应每个顶点𝑣），使得对于每条边(u,v)，都有𝑦𝑢 + 𝑦𝑣 ≥ 1，并且∑𝑦𝑣尽可能小。&lt;/p>
&lt;p>当𝑦𝑣的值小于0.5时，这并不意味着会违反𝑦𝑢 + 𝑦𝑣 ≥ 1的条件。因为即使一个顶点的𝑦值小于0.5，只要它连接的另一个顶点的𝑦值大于0.5，那么这条边仍然可以被覆盖。换句话说，𝑦𝑢 + 𝑦𝑣 ≥ 1的条件是针对每条边来说的，而不是针对每个顶点。&lt;/p>
&lt;p>所以，即使𝑦𝑣的值小于0.5，只要找到的这组𝑦𝑣的值满足对于每条边(u,v)，都有𝑦𝑢 + 𝑦𝑣 ≥ 1，那么就不会违反这个条件。&lt;/p>
&lt;p>这是一个关于图论中顶点覆盖问题的线性规划近似解法的问题。这个方法的基本步骤如下：&lt;/p>
&lt;ol>
&lt;li>写出顶点覆盖问题的线性规划（LP）形式。&lt;/li>
&lt;li>在多项式时间内解决这个LP问题。&lt;/li>
&lt;li>在多项式时间内对LP解进行四舍五入，损失因子为2。&lt;/li>
&lt;/ol>
&lt;p>这个方法被称为2-近似解法，原因如下：&lt;/p>
&lt;p>顶点覆盖问题的目标是找到一个最小的顶点集合，使得图中的每条边都至少与集合中的一个顶点相连。在LP解法中，每个顶点被赋予一个0到1之间的值，表示这个顶点被选中的可能性。然后，我们将这些值四舍五入到最近的整数，得到一个顶点覆盖的近似解。&lt;/p>
&lt;p>这个方法的近似比例为2，是因为四舍五入操作可能会导致选中的顶点数目增加。具体来说，如果一个顶点在LP解中的值为0.5，那么在四舍五入后，这个顶点可能会被选中，从而增加了顶点覆盖的大小。然而，由于每个顶点的值都不会超过1，所以这个增加的数量最多不会超过原始LP解的两倍。因此，这个方法被称为2-近似解法。&lt;/p>
&lt;h2 id="set-cover">Set Cover
&lt;/h2>&lt;p>集合覆盖（Set Cover）是计算机科学中的一个经典问题，它是 NP 完全问题的一个例子。&lt;/p>
&lt;p>给定一个有限集合 U 和 U 的若干子集 S1, S2, &amp;hellip;, Sn，集合覆盖问题是要找到最小的子集合的集合，使得这些子集合的并集等于 U。&lt;/p>
&lt;p>例如，如果 U = {1, 2, 3, 4, 5}，S1 = {1, 2, 3}，S2 = {2, 4}，S3 = {3, 4, 5}，那么 {S1, S3} 就是一个集合覆盖，因为 S1 和 S3 的并集等于 U。&lt;/p>
&lt;p>集合覆盖问题在许多实际问题中都有应用，例如在无线网络设计、数据库系统、信息检索等领域。在这些问题中，我们通常希望找到一个最小的集合覆盖，以最小化成本或资源使用。&lt;/p>
&lt;p>集合覆盖问题是 NP 完全问题，这意味着没有已知的多项式时间算法可以解决所有的集合覆盖问题。然而，有一些启发式算法和近似算法可以在实际中有效地解决集合覆盖问题，例如贪心算法。&lt;/p>
&lt;h2 id="lp-relaxation-for-set-cover">LP Relaxation for Set Cover
&lt;/h2>&lt;p>这是关于集合覆盖问题的贪心算法近似解法的问题。集合覆盖问题是一个NP完全问题，其决策版本的目标是找到一个最小的子集合，使得这些子集合的并集等于全集。&lt;/p>
&lt;p>贪心算法的基本步骤如下：&lt;/p>
&lt;ol>
&lt;li>初始化一个空的解决方案。&lt;/li>
&lt;li>在每一步，选择一个对当前解决方案贡献最大的集合，将其添加到解决方案中。这里的&amp;quot;贡献&amp;quot;是指该集合包含的、在当前解决方案中尚未被覆盖的元素数量（如果是加权版本，则还需要除以集合的权重）。&lt;/li>
&lt;li>重复第2步，直到全集被覆盖。&lt;/li>
&lt;/ol>
&lt;p>这个贪心算法的近似比例为1 + ln n，其中n是全集的元素数量。这是因为在每一步，我们总是选择贡献最大的集合，这保证了我们的解决方案不会比最优解差太多。具体来说，无论最优解需要多少个集合k，这个算法总是返回一个至多为k(1 + ln n)的解决方案。&lt;/p>
&lt;p>更严格的分析表明，这个算法的近似因子实际上是(ln n - ln ln n) + Θ(1)。这意味着，随着n的增大，这个算法的性能会逐渐接近最优解。&lt;/p>
&lt;p>然而，已经证明，除非P=NP，否则集合覆盖问题不能在1 - o(1) ⋅ ln n的范围内被近似。这意味着，我们不能期望有一个在多项式时间内运行的近似算法，其近似因子的增长速度比c ⋅ ln n慢，其中c &amp;lt; 1。&lt;/p>
&lt;p>这是关于贪心算法在集合覆盖问题中的近似比例证明的问题。证明的基本思路如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>假设最优解包含k个集合。在每一次贪心迭代中，未被覆盖的元素数量会减少一个因子1 - 1/k。这是因为我们总是选择贡献最大的集合，而这个集合至少包含了最优解中每个集合的平均贡献。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于我们开始时有n个未被覆盖的元素，所以在进行k ln n次迭代后，所有的元素都会被覆盖。这里的ln n是因为在每次迭代中，未被覆盖的元素数量都会减少一个因子1 - 1/k，所以需要ln n次迭代才能将这个数量减少到1以下。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于实际的迭代次数可能不是整数，所以我们需要向上取整，得到⌈k ln n⌉。这意味着，我们的解决方案的大小最多为最优解的1 + ln n倍。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这个证明表明，贪心算法在集合覆盖问题中的近似比例为1 + ln n，这是一个对数级别的近似比例。这也解释了为什么这个算法被称为对数级别的贪心算法。&lt;/p>
&lt;h2 id="duality">Duality
&lt;/h2>&lt;p>线性规划的对偶性是一个非常重要的概念。对于每一个线性规划问题（称为原问题），都存在一个相关的线性规划问题（称为对偶问题）。原问题和对偶问题之间有一些非常有趣的关系。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>对偶问题的目标函数是原问题的约束条件的线性组合，反之亦然。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对偶问题的解（对偶值）提供了原问题解（原值）的一个下界（如果是最大化问题）或上界（如果是最小化问题）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果原问题和对偶问题都有解（即它们是可行的），那么它们的最优解是相等的。这就是所谓的弱对偶性。如果原问题是无界的，那么对偶问题是不可行的，反之亦然。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在某些条件下（例如，如果原问题和对偶问题都满足某些正则性条件），我们可以保证强对偶性，即原问题的任何可行解和对偶问题的任何可行解都有相同的目标函数值。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这些对偶性质在解决线性规划问题时非常有用。例如，它们可以用来检验解的最优性，提供解的上下界，以及通过解对偶问题来更有效地解原问题。&lt;/p>
&lt;h2 id="近似算法">近似算法
&lt;/h2>&lt;p>近似算法是一种在有限时间内找到最优解的近似解的算法。在许多情况下，找到最优解可能需要非常长的时间，或者甚至是不可能的。在这种情况下，近似算法可以提供一个可接受的、接近最优的解。近似算法的一个主要优点是它们通常可以在多项式时间内运行，这使得它们在处理大规模问题时非常有用。&lt;/p>
&lt;h2 id="lps-作为有效的松弛">LPs 作为有效的松弛
&lt;/h2>&lt;p>在优化问题中，松弛是一种将一个难以解决的问题转化为一个更容易解决的问题的技术。线性规划可以作为一种有效的松弛技术，将一些难以直接解决的问题转化为线性规划问题。通过这种方式，我们可以利用线性规划的强大求解能力来解决更复杂的问题。&lt;/p>
&lt;h2 id="舍入对偶拟合原始-对偶方法">舍入、对偶拟合、原始-对偶方法
&lt;/h2>&lt;p>这些都是处理线性规划问题的技术。舍入是一种将连续解转化为离散解的方法；对偶拟合是一种通过解对偶问题来找到原问题解的方法；原始-对偶方法是一种同时解原问题和对偶问题的方法。这些技术都是为了在实际应用中更好地解决线性规划问题。&lt;/p></description></item><item><title>Hash</title><link>https://shyu216.github.io/aquamega/p/hash/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/hash/</guid><description>&lt;ul>
&lt;li>喜欢很少更新数据的情况，static dictionary search&lt;/li>
&lt;/ul>
&lt;h2 id="univeral-hashing">Univeral Hashing
&lt;/h2>&lt;p>通用哈希函数族具有以下性质：&lt;/p>
&lt;p>如果我们从哈希函数族 H 中均匀随机地选择一个哈希函数 h，那么对于 U 中的每一对不同的元素 x 和 y，x 和 y 在 h 下发生冲突的概率满足：&lt;/p>
&lt;p>$Pr_{h \in H}[h(x) = h(y)] \leq \frac{1}{m}$&lt;/p>
&lt;p>这里，$Pr_{h \in H}[h(x) = h(y)]$ 表示在哈希函数族 H 中选择的哈希函数 h 使得 x 和 y 发生冲突的概率，m 是哈希表的大小。&lt;/p>
&lt;p>给定一个包含 n 个元素的集合 S，我们从一个通用的函数族 H 中均匀随机地选择一个哈希函数 h，我们可以达到以下效果：&lt;/p>
&lt;ul>
&lt;li>预处理时间：最坏情况下为 O(n + m)；&lt;/li>
&lt;li>空间消耗：最坏情况下为 O(n + m)；&lt;/li>
&lt;li>查询时间：期望为 O(1 + n/m)。找到哈希值的时间为 O(1)，解决冲突的时间为 O(n/m)，比如遍历桶中元素，平均有n/m个。&lt;/li>
&lt;/ul>
&lt;p>如上所述，m 控制了空间消耗和期望查询时间之间的权衡。&lt;/p>
&lt;p>当 m = Θ(n) 时，空间消耗为 O(n)，期望查询时间为 O(1)。&lt;/p>
&lt;h3 id="when-m--n">when $m = n$
&lt;/h3>&lt;ul>
&lt;li>查询时间：O(1)，expected&lt;/li>
&lt;/ul>
&lt;h3 id="when-m--n2">when $m = n^2$
&lt;/h3>&lt;p>理论上此时碰撞期望小于1。&lt;/p>
&lt;ul>
&lt;li>预处理时间：O(n^2)&lt;/li>
&lt;li>空间消耗：O(n^2)&lt;/li>
&lt;li>查询时间：O(1)，worst case&lt;/li>
&lt;/ul>
&lt;h2 id="perfect-hashing">Perfect Hashing
&lt;/h2>&lt;p>两层的哈希表，第一层用于解决冲突，第二层用于存储数据。&lt;/p>
&lt;p>第一层m=n，第二层m=n^2。&lt;/p>
&lt;ul>
&lt;li>预处理时间：O(n)&lt;/li>
&lt;li>空间消耗：O(n)&lt;/li>
&lt;li>查询时间：O(1)，worst case&lt;/li>
&lt;/ul>
&lt;h2 id="cuckoo-hashing">Cuckoo Hashing
&lt;/h2>&lt;p>布谷鸟，k个表，插值时，如果发生冲突，就把原来的元素挤出去，直到找到空位。&lt;/p>
&lt;ul>
&lt;li>插入时间：期望为 O(1)&lt;/li>
&lt;li>删除时间：最坏情况下为 O(1)&lt;/li>
&lt;li>查询时间：最坏情况下为 O(1)&lt;/li>
&lt;li>构建时间：期望为 O(n)&lt;/li>
&lt;li>空间消耗：最坏情况下为 O(n)&lt;/li>
&lt;/ul></description></item><item><title>Quake Heap</title><link>https://shyu216.github.io/aquamega/p/quake-heap/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/quake-heap/</guid><description>&lt;ul>
&lt;li>数据在leaf，整个堆用priority维护，跟实际数据无关&lt;/li>
&lt;li>Insertion: O(1) expected, O(log n) worst case&lt;/li>
&lt;li>Search: N/A (or O(n) if heap is traversed)&lt;/li>
&lt;li>Decrease Key: O(1) expected, O(n) worst case&lt;/li>
&lt;li>Deletion (Delete Min): O(log n) expected, O(n) worst case&lt;/li>
&lt;/ul>
&lt;p>Quake Heaps 是一种优先队列数据结构，它在处理动态集合中的元素和执行相关操作（如插入、删除、查找最小元素等）时，提供了良好的时间复杂性。Quake Heaps 的一个关键特性是它们的删除操作的摊还时间复杂度为 $O(\log n)$，这使得它们在需要频繁删除操作的应用中非常有用。&lt;/p>
&lt;p>以下是一些可能使用 Quake Heaps 的应用：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>图算法&lt;/strong>：许多图算法，如 Dijkstra 的最短路径算法和 Prim 的最小生成树算法，需要使用优先队列来高效地找到下一个要处理的节点。在这些算法中，Quake Heaps 可以用来提高性能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>事件驱动的模拟&lt;/strong>：在事件驱动的模拟中，事件是按照它们发生的时间顺序处理的。Quake Heaps 可以用来存储和检索这些事件，以确保它们按照正确的顺序被处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>任务调度&lt;/strong>：在任务调度问题中，我们需要根据任务的优先级来决定执行顺序。Quake Heaps 可以用来存储和检索任务，以确保优先级最高的任务首先被执行。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>请注意，虽然 Quake Heaps 在理论上有很好的性能，但在实践中，由于它们的实现复杂性，可能会选择其他更简单但性能稍差的数据结构，如 Fibonacci heaps 或 binary heaps。&lt;/p>
&lt;h2 id="tournament-trees">Tournament Trees
&lt;/h2>&lt;p>Quake Heaps 是基于 Tournament Trees 的一种改进。Tournament Trees 是一种完全二叉树，其中每个节点都包含一个元素，并且树的叶子节点是输入元素。在 Tournament Trees 中，每个节点都存储了其子树中的最小元素。这使得 Tournament Trees 可以用来高效地找到最小元素。&lt;/p>
&lt;h2 id="pointers">Pointers
&lt;/h2>&lt;p>P即T的最后一层，每个节点都是一个元素。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>元素指针&lt;/strong>：在优先队列 P 中，每个元素都保持一个指向 Tournament Tree T 中概念上存储其优先级的最高节点（即，高度最大的节点）的指针。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>节点指针&lt;/strong>：在 Tournament Tree T 中，每个节点 u 都有一个指向优先队列 P 中的元素的指针，u 概念上存储了该元素的优先级。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="node-number-at-height-invariant">Node-Number-at-Height Invariant
&lt;/h2>&lt;p>在 Quake Heaps 中，有一个重要的不变性，即“高度 h 处的节点数目”不变性。&lt;/p>
&lt;p>有一个constant $c$，上一层的节点数目是下一层的节点数目的 $c$ 倍。这个不变性保证了 Quake Heaps 的高效性。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">c = 0.6
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">n5 = 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">n4 = 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">n3 = 5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">n2 = 9
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">n1 = 15
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>$n_{h+1} \leq c \cdot n_h$&lt;/p>
&lt;h2 id="log-n">log n
&lt;/h2>&lt;ol>
&lt;li>最后一层至多n个&lt;/li>
&lt;li>每层会少c倍&lt;/li>
&lt;li>层数至多$\log_{1/c} n$&lt;/li>
&lt;/ol>
&lt;h2 id="operations">Operations
&lt;/h2>&lt;h3 id="link">Link
&lt;/h3>&lt;p>将两个 Tournament Trees 连接成一个更大的 Tournament Tree。这个操作的时间复杂度是 $O(1)$。&lt;/p>
&lt;p>条件：两个 Tournament Trees 的高度相同。&lt;/p>
&lt;h3 id="cut">Cut
&lt;/h3>&lt;p>切根和较大的子节点。这个操作的时间复杂度是 $O(1)$。&lt;/p>
&lt;h3 id="insert">Insert
&lt;/h3>&lt;p>直接插入，建个新树。这个操作的时间复杂度是 $O(1)$。&lt;/p>
&lt;h3 id="decrease-key">Decrease Key
&lt;/h3>&lt;p>降低一个元素的优先级。把它的值减小，找到它指的树中的节点，然后cut。这个操作的时间复杂度是 $O(1)$。&lt;/p>
&lt;h3 id="delete-min">Delete Min
&lt;/h3>&lt;p>找到最小的元素，删掉整个path。通常先经过decrease key，使目标数据有最小priority，操作更方便。要是有same height，link起来。&lt;/p>
&lt;p>这个操作的时间复杂度是 $O(\log n)$，可以用admortized analysis证明。&lt;/p>
&lt;ul>
&lt;li>跟树的数量，和path的长度有关。&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>找到具有最小键值的元素。
&lt;ul>
&lt;li>有T个树，需T步&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除这个元素。
&lt;ul>
&lt;li>如path长L，有L步&lt;/li>
&lt;li>1和2共T+L&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>同一高度的树合并。while loop
&lt;ul>
&lt;li>T-1个其他树，切掉path后有L个新树，共T+L-1步&lt;/li>
&lt;li>仅需T+L-2个合并，因为至少剩下一个树&lt;/li>
&lt;li>$T^{(1)} \leq 2h^{(0)}_{max}$，合并后的树的数量小于等于合并前最高的树的高度的2倍&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>保持不变性。
&lt;ul>
&lt;li>只会删node，而不加，把不符的高层整层删掉，$\Delta N &amp;lt; 0$&lt;/li>
&lt;li>新增的树不会比新的最高层的node多，$\Delta T \leq n^{(0)}_h$&lt;/li>
&lt;li>只会删坏节点，而不加，按层删的，所以就算往上一层h+1坏节点。这一层的节点数是两倍上一层的好节点和一倍上一层的坏节点，所以$n_h = 2(n_{h+1} - b_{h+1}) + 1*b_{h+1}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="admortized-analysis">Admortized Analysis
&lt;/h2>&lt;p>N个元素，T个树，B个坏节点（只有一个孩子）&lt;/p>
&lt;p>$\Phi = N + 3T + \frac{3}{2\alpha -1}B$&lt;/p>
&lt;h2 id="t1-leq-2h0_max">$T^{(1)} \leq 2h^{(0)}_{max}$
&lt;/h2>&lt;ul>
&lt;li>每种高度的树最多有一个，不然就被合并了&lt;/li>
&lt;li>合并后的高度至多是原来的两倍&lt;/li>
&lt;li>合并前至多有$h^{(0)}&lt;em>{max}$种高度的树，每种合并一次，最后高度会是$2h^{(0)}&lt;/em>{max}$&lt;/li>
&lt;/ul></description></item><item><title>Range Search</title><link>https://shyu216.github.io/aquamega/p/range-search/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/range-search/</guid><description>&lt;ul>
&lt;li>用于范围查询（一次多个值）&lt;/li>
&lt;/ul>
&lt;p>对于二维数据：&lt;/p>
&lt;ul>
&lt;li>构建时间：O(n log n)&lt;/li>
&lt;li>空间消耗：O(n log n)，log n层，每层至多n个&lt;/li>
&lt;li>查询时间：O(k + log n)，其中 k 是报告的点的数量。&lt;/li>
&lt;/ul>
&lt;h2 id="查询算法">查询算法
&lt;/h2>&lt;p>给定一个查询范围 Q = [a1, b1] × [a2, b2]，我们可以通过以下步骤报告所有在 P ∩ Q 中的点：&lt;/p>
&lt;ol>
&lt;li>在 Tx 中找到 a&amp;rsquo; = succ(a1) 和 b&amp;rsquo; = pred(b1)；&lt;/li>
&lt;li>让 usplit = LCA(a&amp;rsquo;, b&amp;rsquo;)，La1 是从 usplit 的左孩子到 a&amp;rsquo; 的路径，Lb1 是从 usplit 的右孩子到 b&amp;rsquo; 的路径；&lt;/li>
&lt;li>如果 usplit ∈ Q，报告 usplit；&lt;/li>
&lt;li>对于路径 La1 上的每个节点 u：
&lt;ul>
&lt;li>如果 u ∈ Q，报告 u；&lt;/li>
&lt;li>如果 a&amp;rsquo; ≤ u.x，那么报告 u 的右子树中所有 y 坐标在 [a2, b2] 范围内的点；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对于路径 Lb1 上的每个节点 u：
&lt;ul>
&lt;li>如果 u ∈ Q，报告 u；&lt;/li>
&lt;li>如果 b&amp;rsquo; ≥ u.x，那么报告 u 的左子树中所有 y 坐标在 [a2, b2] 范围内的点。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>这个算法的基本思想是首先在 x 轴上找到查询范围的边界，然后在这个范围内的每个节点上进行 y 轴的范围搜索。这是一个有效的方法，因为它可以利用二维空间的结构来减少搜索的复杂性。&lt;/p>
&lt;p>在开始时，我们承诺可以在 $O(k + \log n)$ 时间内完成二维轴平行矩形范围查询。然而，当前的查询成本是 $O(k + \log^2 n)$，这违反了我们的承诺。&lt;/p>
&lt;p>为了将查询时间从 $O(k + \log^2 n)$ 降低到 $O(k + \log n)$，我们需要应用一种称为分数级联（Fractional Cascading）的技术。&lt;/p>
&lt;p>分数级联是一种用于优化多层次数据结构查询的技术。通过在每一层都保留一部分信息，我们可以避免在每一层都进行完全的二分查找，从而将查询时间从 $\log^2 n$ 降低到 $\log n$。这种技术在处理二维范围查询、最近邻查询等问题时非常有用。&lt;/p>
&lt;h2 id="fractional-cascading">Fractional Cascading
&lt;/h2>&lt;p>分数级联是一种技术，用于加速范围查询。它通过在不同层次的数据结构之间共享信息来减少查询时间。&lt;/p>
&lt;p>succ和pred指针，指向下一层的元素。&lt;/p>
&lt;p>这段文字是在描述如何通过应用分数级联（Fractional Cascading）技术来优化二维轴平行矩形范围查询的时间复杂度。&lt;/p>
&lt;p>基于上述观察，我们可以将所有的次级树替换为排序数组，并应用分数级联技术，以将 $O(k + \log^2 n)$ 的查询时间降低到 $O(\log n + k + \log n) = O(k + \log n)$。&lt;/p>
&lt;p>分数级联的基本思想是在每一层的数据结构中保留一部分信息，以便在查询时可以快速定位到下一层的查询位置，从而避免在每一层都进行完全的二分查找。在这个上下文中，我们将次级树替换为排序数组，然后在每个数组中保留一部分信息，以便在查询时可以快速定位到下一个数组的查询位置。&lt;/p>
&lt;p>这种方法可以将查询时间从 $O(k + \log^2 n)$ 降低到 $O(k + \log n)$，从而满足我们在开始时的承诺。&lt;/p>
&lt;h2 id="实现">实现
&lt;/h2>&lt;p>在范围树中实现分数级联（Fractional Cascading）可以有效地减少查询时间。以下是一个简单的实现步骤：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在构建范围树时，每个节点都存储其子节点的最大和最小值。这样，我们可以快速确定一个查询范围是否与一个子树有交集。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于每个节点，我们在其左右子节点中存储一个指向其父节点的指针。这样，我们可以从一个子节点快速跳转到其父节点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当我们进行范围查询时，我们首先在树的根节点开始。我们检查查询范围是否与左右子树有交集。如果有交集，我们就跟踪这个子树，并更新查询范围以排除已经检查过的部分。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当我们跟踪一个子树时，我们使用存储在节点中的指针，快速跳转到其父节点。然后，我们重复步骤3，直到我们检查了所有与查询范围有交集的子树。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后，我们返回所有在查询范围内的节点。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>通过这种方式，我们可以在 O(log n + k) 的时间内完成查询，其中 n 是树中的节点数量，k 是查询返回的节点数量。这比没有使用分数级联的 O(n log n + k) 快得多。&lt;/p></description></item><item><title>Splay Tree</title><link>https://shyu216.github.io/aquamega/p/splay-tree/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/splay-tree/</guid><description>&lt;ul>
&lt;li>越常访问，越靠近root&lt;/li>
&lt;li>一种balanced BST，但不保证平衡&lt;/li>
&lt;li>Insertion: O(log n) expected, O(n) worst case&lt;/li>
&lt;li>Search: O(log n) expected, O(n) worst case&lt;/li>
&lt;li>Deletion: O(log n) expected, O(n) worst case&lt;/li>
&lt;/ul>
&lt;h2 id="zig-zig-and-zag-zag">Zig-Zig and Zag-Zag
&lt;/h2>&lt;p>left-left/right-right turns to right-right/left-left&lt;/p>
&lt;h2 id="zig-zag-and-zag-zig">Zig-Zag and Zag-Zig
&lt;/h2>&lt;p>turns to middle&lt;/p>
&lt;h2 id="zig-and-zag">Zig and Zag
&lt;/h2>&lt;p>just swap&lt;/p>
&lt;h2 id="successful-search-only-sequence">Successful-search-only sequence
&lt;/h2>&lt;p>&amp;ldquo;Successful-search-only sequence&amp;rdquo; 是一种特定的操作序列，其中只包含成功的搜索操作。在这种序列中，所有的搜索操作都能找到它们正在寻找的元素。&lt;/p>
&lt;p>这种操作序列在分析某些数据结构的性能时非常有用。例如，当我们分析哈希表的性能时，我们可能会考虑最坏情况下的操作序列，其中包含大量的失败的搜索操作。然而，在实际应用中，失败的搜索操作可能非常少，因此，考虑 &amp;ldquo;successful-search-only sequence&amp;rdquo; 可能会给出更准确的性能分析。&lt;/p>
&lt;p>在 &amp;ldquo;successful-search-only sequence&amp;rdquo; 中，由于所有的搜索操作都是成功的，所以数据结构的性能主要取决于如何高效地存储和检索元素。因此，这种操作序列对于理解和优化数据结构的性能非常有用。&lt;/p>
&lt;h2 id="information-theory">Information theory
&lt;/h2>&lt;p>信息理论能够帮助我们理解数据结构的性能。在信息理论中，我们可以使用熵来衡量数据的不确定性。熵越高，数据的不确定性就越大。&lt;/p>
&lt;p>它可以用来界定最优的成本界限。&lt;/p></description></item><item><title>Admortized Analysis</title><link>https://shyu216.github.io/aquamega/p/admortized-analysis/</link><pubDate>Tue, 11 Jun 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/admortized-analysis/</guid><description>&lt;p>$\sum_{i=1}^{m} cost(\sigma_i) \leq \sum_{i=1}^{m} a(\sigma_i)$&lt;/p>
&lt;p>摊还分析是一种分析数据结构操作成本的方法，它将操作的成本在一系列操作中进行平均，而不是单独考虑每个操作。&lt;/p>
&lt;p>我们的目标是证明对于任何一系列的动态数组操作 $\sigma_1,&amp;hellip;,\sigma_m$，如果每个操作的摊还成本 $a(\sigma_i)$ 是 $O(1)$（即常数时间），那么整体的成本不等式 $\sum_{i=1}^{m} cost(\sigma_i) \leq \sum_{i=1}^{m} a(\sigma_i)$ 就能成立。&lt;/p>
&lt;p>这个不等式的含义是，所有操作的实际总成本（左边的部分）不会超过所有操作的摊还总成本（右边的部分）。这是摊还分析的一个重要性质，它保证了我们的摊还成本确实反映了实际的成本。&lt;/p>
&lt;h2 id="prepaid">Prepaid
&lt;/h2>&lt;p>$\sum_{i=1}^{m} a(\sigma_i) = \sum_{i=1}^{m} cost(\sigma_i) + \sum_{i=1}^{m} \Beta$&lt;/p>
&lt;p>where $\Beta \geq 0$ (总是有余额)&lt;/p>
&lt;p>&amp;ldquo;Prepaid&amp;rdquo;（预付）是摊还分析中的一个概念，它描述的是一种策略，即在执行一些高成本的操作之前，先执行一些低成本的操作来“预付”高成本操作的部分或全部成本。&lt;/p>
&lt;p>例如，考虑一个动态数组的插入操作。当数组满时，我们需要分配一个新的、更大的数组，并将旧数组中的所有元素复制到新数组中。这个操作的成本是线性的。然而，如果我们将这个成本均摊到之前的每次插入操作上，那么每次插入操作的摊还成本就是常数的。这就是预付策略的一个例子：我们通过每次插入操作“预付”一部分成本，来避免在数组满时一次性支付所有的成本。&lt;/p>
&lt;p>预付策略的一个关键思想是，我们可以将一些高成本的操作的成本分摊到多个低成本的操作上，从而使得所有操作的摊还成本都保持在一个可接受的范围内。这种策略在设计和分析高效的数据结构和算法时非常有用。&lt;/p>
&lt;h2 id="potential-function">Potential Function
&lt;/h2>&lt;p>$\sum_{i=1}^{m} a(\sigma_i) = \sum_{i=1}^{m} cost(\sigma_i) + \sum_{i=1}^{m} \Phi(D_i) - \Phi(D_0)$&lt;/p>
&lt;p>where $\Phi(D_0)$ = 0, $\Phi(D_i) \geq 0$（不能超出势能）&lt;/p>
&lt;p>在摊还分析中，我们经常使用势能方法来证明摊还成本。下面是一个经典的例子：动态数组的插入操作。&lt;/p>
&lt;p>动态数组是一种可以动态增长和缩小的数组。当我们向动态数组中插入元素时，如果数组已满，我们需要创建一个新的、更大的数组，然后将旧数组中的所有元素复制到新数组中。这个操作的成本是线性的。然而，如果我们使用摊还分析，我们可以证明每次插入操作的摊还成本是常数的。&lt;/p>
&lt;p>我们定义势能函数 $\Phi$ 为数组的当前大小减去数组中的元素数量。当我们插入一个元素时，有两种情况：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>如果数组没有满，我们只需要在数组的末尾添加一个元素。这个操作的实际成本是 $1$，势能的变化是 $-1$，所以摊还成本是 $1 - (-1) = 2$。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果数组已满，我们需要创建一个新的、大小为 $2n$ 的数组，并将 $n$ 个元素复制到新数组中。这个操作的实际成本是 $n+1$，势能的变化是 $n - n = 0$，所以摊还成本是 $n+1 - 0 = n+1$。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>在第二种情况中，摊还成本看起来是线性的。然而，这种情况只会发生在插入操作的数量是当前数组大小的整数倍时。在大多数情况下，我们处于第一种情况，摊还成本是常数的。因此，我们可以说插入操作的摊还成本是常数的，即 $a(\sigma_i) \in O(1)$。&lt;/p></description></item><item><title>log n，n，2^n的关系</title><link>https://shyu216.github.io/aquamega/p/log-nn2n%E7%9A%84%E5%85%B3%E7%B3%BB/</link><pubDate>Tue, 11 Jun 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/log-nn2n%E7%9A%84%E5%85%B3%E7%B3%BB/</guid><description>&lt;h2 id="big-o-notation">Big-O Notation
&lt;/h2>&lt;p>$$ f(n) \in O(g(n)) \text{ iff } \exists c_1, c_2, \forall n &amp;gt; c_2, f(n) \leq c_1 \cdot g(n)$$&lt;/p>
&lt;h2 id="olog-n-subset-onk-subset-o2n">$O(\log n) \subset O(n^k) \subset O(2^n)$
&lt;/h2>&lt;p>求证？设新方程，用相除或相减把不等式移到同一边，然后证明单调性，且大于1或大于0，取得$c_1, c_2$的值。&lt;/p></description></item><item><title>Max-Flow Min-Cut Theorem</title><link>https://shyu216.github.io/aquamega/p/max-flow-min-cut-theorem/</link><pubDate>Tue, 11 Jun 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/max-flow-min-cut-theorem/</guid><description>&lt;p>&lt;strong>请注意&lt;/strong>！本文是由公元2024年的GPT生成的，可能包含一些不准确的信息。&lt;/p>
&lt;p>最大流（Max-Flow）问题和最小割（Min-Cut）问题在网络流中是两个互相关联的问题，它们的关系通常被称为最大流-最小割定理（Max-Flow Min-Cut Theorem）。&lt;/p>
&lt;p>最大流-最小割定理是网络流中的一个基本定理，它指出了一个网络的最大流量和该网络的最小割的容量之间的关系。具体来说，对于任何网络，其最大流量等于其最小割的容量。&lt;/p>
&lt;p>在一个网络流图中，流量从源节点（source）流向汇节点（sink）。最大流问题就是要找到一种流的分配方式，使得从源节点到汇节点的总流量最大。&lt;/p>
&lt;p>割（cut）是将网络图分割成两部分的一种方式，其中一部分包含源节点，另一部分包含汇节点。割的容量（capacity）是从源节点部分到汇节点部分的所有边的容量之和。最小割问题就是要找到一种割的方式，使得割的容量最小。&lt;/p>
&lt;h2 id="kargers-algorithm-for-min-cut">Karger&amp;rsquo;s Algorithm for Min Cut
&lt;/h2>&lt;p>David Karger 的最小割算法是一种随机化算法，用于在无向图中找到最小割。这个算法基于一种称为“边收缩”（edge contraction）的操作。&lt;/p>
&lt;p>这个算法的期望运行时间是多项式的，但是它可能需要多次运行才能找到真正的最小割。为了提高找到最小割的概率，我们可以多次运行这个算法，并返回所有运行中找到的最小割。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Adjacency list&lt;/p>
&lt;p>邻接列表是一种表示图的方法，它为图中的每个顶点维护一个列表，列出了从该顶点出发可以到达的所有顶点。在 Python 中，我们通常使用字典来实现邻接列表，其中键是顶点，值是一个列表，包含了所有连接到该顶点的顶点。邻接列表是一种空间效率高的数据结构，特别适合于稀疏图，即边的数量远小于顶点的数量的平方的图。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Union-Find&lt;/p>
&lt;p>并查集是一种用于处理不相交集合的数据结构。它支持两种操作：查找和合并。查找操作 Find(x) 用于找到包含元素 x 的集合的代表元素。合并操作 Merge(x, y) 用于将包含元素 x 和 y 的两个集合合并为一个集合。并查集的一个重要特性是，这两种操作的时间复杂度都接近于常数，这使得它在处理大规模数据时非常高效。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="greedy-algorithm-for-max-flow">Greedy Algorithm for Max Flow
&lt;/h2>&lt;ol>
&lt;li>初始化所有边的流量为0。&lt;/li>
&lt;li>寻找一条从源点s到目标点t的路径，这条路径上的每一条边的流量都小于其容量。&lt;/li>
&lt;li>沿着找到的这条路径尽可能多地增加流量，找到路径上剩余容量最小的边，然后增加这个量的流量。&lt;/li>
&lt;/ol>
&lt;p>我们重复以上步骤，直到无法找到满足条件的路径为止。&lt;/p>
&lt;ul>
&lt;li>无法保证最优。贪心算法可能会选择一条在当前看来可以增加最多流量的路径。然而，这可能会导致在后续的步骤中，无法找到新的路径来进一步增加流量。&lt;/li>
&lt;/ul>
&lt;h2 id="ford-fulkerson-algorithm-for-max-flow">Ford-Fulkerson Algorithm for Max Flow
&lt;/h2>&lt;p>Ford-Fulkerson 算法是一种解决最大流问题的经典方法。这个算法的基本步骤如下：&lt;/p>
&lt;ol>
&lt;li>初始流设为零。&lt;/li>
&lt;li>只要在残余网络中存在一条从源节点 s 到汇点 t 的路径，就执行以下操作：
&lt;ul>
&lt;li>寻找一条可以增加流量的路径。&lt;/li>
&lt;li>更新流量和残余网络。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>返回最后计算出的流量。&lt;/li>
&lt;/ol>
&lt;h3 id="proofs">Proofs
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>在每一次迭代中，流量都是整数：这可以通过数学归纳法来证明。初始的流量是零，是一个整数。在每次迭代中，我们都在一条路径上增加整数的流量，所以流量始终是整数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在每次迭代中，流量增加了 KP：这可以通过观察源节点 s 和路径来证明。在每次迭代中，我们都在一条从 s 到 t 的路径上增加流量，所以总流量会增加。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>算法会在有限的步骤后停止（最多在 𝐶 = ∑(对所有边的容量𝑐求和) 迭代后）：这可以从前面的证明推断出来。因为每次迭代都会增加流量，而总流量受到网络容量的限制，所以算法一定会在有限的步骤后停止。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="running-time">Running time
&lt;/h3>&lt;p>Ford-Fulkerson（FF）算法的运行时间取决于多个因素，包括图的结构、边的容量以及选择增广路径的策略。在每次迭代中，算法需要在残余图中找到一条源节点s到目标节点t的路径，然后根据这条路径更新流量和残余图。&lt;/p>
&lt;p>每次迭代的时间复杂度为O(m)，其中m是图中的边的数量，原因如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在残余图中找到一条s-t路径：这可以通过深度优先搜索（DFS）或广度优先搜索（BFS）来完成，时间复杂度为O(m)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>更新流量和残余图：一旦找到了一条增广路径，我们需要遍历这条路径上的所有边，更新它们的流量和残余容量。这个过程的时间复杂度也为O(m)，因为一条路径上的边的数量最多为m。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>因此，每次迭代的时间复杂度为O(m)。然而，需要注意的是，FF算法的总运行时间并不是多项式时间，因为算法的迭代次数取决于最大流量，而这可能远大于图的大小。&lt;/p>
&lt;p>循环的次数最多是 C，其中 C 是图中所有边的容量之和。这是因为在每次循环中，我们至少增加一单位的流量，因此最多需要 C 次循环。&lt;/p>
&lt;p>因此，总的运行时间是 O(Cm)。而实际情况一般是线性时间。&lt;/p>
&lt;h4 id="flow-vs-cut">Flow vs Cut
&lt;/h4>&lt;p>在最大流最小割定理中，流等于割是因为在流网络中，流的大小受限于割的容量。这个定理告诉我们，任何流网络的最大流都等于其某个割的最小容量。&lt;/p>
&lt;p>这是因为：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>流的大小不能超过任何割的容量。这是因为割定义了从源点到汇点的所有可能的路径，流必须通过这些路径，因此不能超过割的容量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在最大流的情况下，存在一个割，其容量等于流的大小。这是因为当我们找到最大流时，我们已经找到了一种方式，使得所有从源点到汇点的路径都被充分利用，这就形成了一个割。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>在最大流最小割定理中，可达性（reachability）的概念是非常重要的。我们可以通过以下步骤使用可达性来证明这个定理：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先，我们找到流网络中的一个最大流。在这个流中，我们可以找到一个割，即一个将网络分割成两部分的边集，使得所有的流都从割的一边（源点所在的一边）流向另一边（汇点所在的一边）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后，我们考虑在残余网络中从源点开始的可达性。在残余网络中，一个节点是可达的，如果存在一条从源点到该节点的路径，路径上的所有边在残余网络中都有正的容量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在最大流的情况下，汇点在残余网络中是不可达的，因为所有的流都已经达到了最大值，没有更多的容量可以从源点流向汇点。这意味着存在一个割，将可达的节点和不可达的节点分开，割的容量等于最大流的值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因此，我们证明了最大流等于最小割。这是因为我们找到了一个割，其容量等于最大流的值，而任何其他割的容量必须大于或等于这个值，因为流的大小不能超过割的容量。所以，这个割就是最小割，其容量（即最小割的值）等于最大流的值。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="flow-value-lemma">Flow-Value Lemma
&lt;/h4>&lt;p>流量值引理（Flow-Value Lemma）是网络流问题中的一个重要概念，它描述了流入和流出一个节点的总流量之间的关系。&lt;/p>
&lt;p>流量值引理的内容如下：&lt;/p>
&lt;p>对于任何流网络中的节点 v（除了源点 s 和汇点 t），流入节点 v 的总流量等于流出节点 v 的总流量。这个性质也被称为流的守恒性质，因为它意味着除了源点和汇点之外，没有流量在任何节点处被创建或消失。&lt;/p>
&lt;p>数学上，这可以表示为：&lt;/p>
&lt;p>对于所有节点 v（v ≠ s, v ≠ t），∑&lt;em>{u ∈ V} f(u, v) = ∑&lt;/em>{u ∈ V} f(v, u)&lt;/p>
&lt;p>其中 V 是节点的集合，f(u, v) 是从节点 u 到节点 v 的流量。&lt;/p>
&lt;p>这个引理是网络流问题中的基本性质，它是许多网络流算法，包括 Ford-Fulkerson 算法和 Edmonds-Karp 算法的基础。&lt;/p>
&lt;h4 id="weak-duality">Weak Duality
&lt;/h4>&lt;p>弱对偶性（Weak Duality）在流量值特征（flow value characterization）中的应用是网络流问题的一个重要概念。它提供了流量值的一个上界。&lt;/p>
&lt;p>弱对偶性定理的内容如下：&lt;/p>
&lt;p>对于任何流网络和任何割（s-t cut），流量值总是小于或等于割的容量。换句话说，最大流的值总是小于或等于最小割的值。&lt;/p>
&lt;p>在流量值特征中，这个定理意味着我们可以通过寻找最小割来得到流量值的一个上界。这个上界对于理解和解决网络流问题非常有用，因为它提供了一个我们无法超过的流量值。&lt;/p>
&lt;p>此外，这个定理还证明了最大流最小割定理（Max-Flow Min-Cut Theorem）的一部分。最大流最小割定理是网络流问题中的一个重要定理，它表明在任何流网络中，最大流的值等于最小割的值。弱对偶性定理证明了这个定理的“小于等于”部分，而“等于”部分需要通过 Ford-Fulkerson 算法或其变种来证明。&lt;/p>
&lt;h3 id="optimality">Optimality
&lt;/h3>&lt;p>所有穿过割的边要么是从 A 到 B 并且满流，要么是从 B 到 A 并且空流。&lt;/p>
&lt;h2 id="perfect-matchings">Perfect Matchings
&lt;/h2>&lt;p>在图论中，&amp;ldquo;匹配&amp;rdquo;（Matching）是指图的一个边的子集，使得子集中的任意两条边都不共享顶点。这是一种将图中的一部分顶点配对的方式，每对配对都通过一条边连接。匹配不一定需要包含图中的所有顶点。&lt;/p>
&lt;p>&amp;ldquo;完美匹配&amp;rdquo;（Perfect Matching）是匹配的一种特殊情况。在完美匹配中，图的每个顶点都恰好与子集中的一条边相连。换句话说，如果一个图有 n 个顶点，那么它的一个完美匹配就会有 n/2 条边。&lt;/p>
&lt;p>完美匹配在许多问题中都有应用，例如在网络设计、任务分配、市场匹配等问题中。在这些问题中，我们通常希望找到一个完美匹配，使得某种成本或效益最优化。&lt;/p>
&lt;p>例如，二分图的最大匹配问题就是要找到一个最大的匹配，即一个最大的边集，使得集合中的任意两条边都不共享端点。这个问题可以通过将其转化为最大流问题来解决。&lt;/p>
&lt;h2 id="bipartite-matching">Bipartite Matching
&lt;/h2>&lt;p>二分匹配（Bipartite Matching）是图论中的一个重要概念，它是在二分图（Bipartite Graph）中进行的匹配。&lt;/p>
&lt;p>二分图是一种特殊的图，它的所有顶点可以被分成两个互不相交的集合，使得每一条边的两个端点分别属于这两个不同的集合。在二分图中进行匹配，就是找到边的集合，使得在这个集合中的任意两条边都不共享端点。&lt;/p>
&lt;p>二分匹配有许多实际应用，例如在任务分配、稳定婚姻问题、市场均衡等问题中都有应用。在这些问题中，我们通常希望找到一个最大的匹配，也就是包含最多边的匹配。&lt;/p>
&lt;p>加s和t就能当max-flow问题解了。&lt;/p>
&lt;p>&amp;ldquo;请说&amp;rsquo;相邻&amp;rsquo;而不是&amp;rsquo;连接&amp;rsquo;&amp;quot;：在图论中，&amp;ldquo;相邻&amp;quot;和&amp;quot;连接&amp;quot;这两个词有着不同的含义。如果两个节点之间有一条边，我们通常说这两个节点是&amp;quot;相邻&amp;quot;的。而&amp;quot;连接&amp;quot;通常指的是在一个图中，存在一条路径可以从一个节点到达另一个节点。&lt;/p>
&lt;p>&amp;ldquo;避免使用&amp;rsquo;任何&amp;rsquo;这个词&amp;rdquo;：在描述算法时，&amp;ldquo;任何&amp;quot;这个词可能会引起混淆。比如，如果我们说&amp;quot;任何节点都可以到达任何其他节点&amp;rdquo;，这可能会被误解为在图中存在一条从每个节点到每个其他节点的直接边，而实际上我们可能只是想表达在图中存在一条从每个节点到每个其他节点的路径。&lt;/p>
&lt;h3 id="integrality-theorem">Integrality Theorem
&lt;/h3>&lt;p>整数定理（Integrality Theorem）是网络流问题中的一个重要定理，它表明如果所有边的容量都是整数，那么存在一个最大流，使得每条边的流量也都是整数。&lt;/p>
&lt;p>如果 k 是整数，并且我们只考虑容量为 1 的边，那么每条边的流量 f(e) 必须是 0 或 1。原因是流量必须满足容量约束，也就是说，流量不能超过容量。因此，如果容量为 1，那么流量只能是 0 或 1。&lt;/p>
&lt;p>这个性质在解决一些特殊的网络流问题时非常有用，例如在匹配问题和路由问题中。在这些问题中，我们通常只关心是否存在一条边，而不关心边的具体容量，所以我们可以将所有边的容量设为 1，然后应用整数定理。&lt;/p>
&lt;h3 id="match-to-flow">Match to Flow
&lt;/h3>&lt;p>这个定理表明，在图 G 中的最大匹配数等于在 G&amp;rsquo; 中的最大流量。这个定理的证明分为两部分：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>≤：将最大匹配转化为流量。匹配约束确保我们满足流量约束。匹配约束和匹配大小确保流量值等于匹配大小。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>≥：将最大流量转化为匹配。流量整数性确保我们不会选择边的分数部分。流网络的约束（容量，保守性）确保我们满足匹配约束（每个顶点最多只能与一个匹配边相邻）。流量值引理表明匹配的大小等于流量的值。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这个定理说明了匹配问题和网络流问题之间的深刻联系。通过将匹配问题转化为网络流问题，我们可以使用网络流算法，如 Ford-Fulkerson 算法和 Edmonds-Karp 算法，来解决匹配问题。这种转化方法在解决一些复杂的组合优化问题时非常有用。&lt;/p>
&lt;h2 id="disjoint-paths">Disjoint Paths
&lt;/h2>&lt;p>在图论中，&amp;ldquo;不相交路径&amp;rdquo;（Disjoint Paths）是指一组路径，其中任意两条路径都没有共享的顶点或边。换句话说，这些路径是完全独立的，它们不会在任何地方交叉或重叠。&lt;/p>
&lt;p>不相交路径的概念在许多问题中都有应用，例如在网络设计、路由问题、交通规划等问题中。在这些问题中，我们通常希望找到一组不相交的路径，以便最大化网络的吞吐量，或者避免交通拥堵。&lt;/p>
&lt;p>在有向图中，我们可以通过最大流算法来找出k条边不相交的路径。这个问题可以转化为一个容量为1的最大流问题。&lt;/p>
&lt;p>以下是证明过程：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>只需证明&lt;/strong>：假设我们有k条不相交的路径。我们可以在每条路径上路由一单位的流，不需要其他流。因此，最大流至少为k。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>如果证明&lt;/strong>：假设最大流至少为k。我们需要证明存在至少k条不相交的路径。为了证明这一点，我们可以对携带流的边的数量进行归纳。&lt;/p>
&lt;p>归纳基础：如果最大流为1，那么存在一条从s到t的路径。&lt;/p>
&lt;p>归纳步骤：假设对于所有小于k的最大流，都存在相应数量的不相交路径。现在，我们考虑最大流为k的情况。由于流的整数性质，我们知道存在一条边，其流量为1，我们可以移除这条边，并将总流量减少1。根据归纳假设，剩余的图存在k-1条不相交的路径。加上我们刚才移除的那条边，我们就找到了k条不相交的路径。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>因此，我们可以得出结论：在有向图中，存在k条边不相交的路径当且仅当最大流至少为k。&lt;/p>
&lt;h2 id="scaling-max-flow">Scaling Max Flow
&lt;/h2>&lt;p>在解决最大流问题时，一种常用的策略是使用缩放（Scaling）技术。这种技术的基本思想是先解决一个简化的问题，然后逐步增加问题的规模，直到解决原始问题。&lt;/p>
&lt;p>在最大流问题中，缩放技术通常是这样实现的：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先，我们找到网络中最大的容量 C。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后，我们设置一个阈值，初始值为 C。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我们只考虑容量大于或等于阈值的边，忽略其他边，然后使用 Ford-Fulkerson 算法或 Edmonds-Karp 算法找到这个简化网络的最大流。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后，我们将阈值减半，再次运行最大流算法。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我们重复这个过程，直到阈值为 1。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这种方法的优点是，每次迭代时，我们只需要考虑一部分边，这可以大大减少计算量。此外，由于我们是从大到小逐步减小阈值，所以我们可以利用前一次迭代的结果，这可以进一步提高效率。&lt;/p>
&lt;p>这种方法在处理大规模网络流问题时非常有效，特别是当网络中的容量差异很大时。&lt;/p>
&lt;h2 id="edmonds-karp-algorithm">Edmonds-Karp Algorithm
&lt;/h2>&lt;ol>
&lt;li>找最宽的路径。Dijkstra,$O(m^2lognlogF)$&lt;/li>
&lt;li>找最短的路径。BFS,$O(m^2n)$&lt;/li>
&lt;/ol>
&lt;h2 id="applications">Applications
&lt;/h2>&lt;h3 id="circulation-with-demands">Circulation with Demands
&lt;/h3>&lt;p>多个源点和汇点的网络流问题是网络流问题的一个重要变种。在这个问题中，我们有多个源点和多个汇点，每个源点都有一个流出的需求，每个汇点都有一个流入的需求。我们的目标是找到一种流的分配方式，使得每个源点的流出等于需求，每个汇点的流入等于需求。&lt;/p>
&lt;h2 id="halls-theorem">Hall’s Theorem
&lt;/h2>&lt;p>哈尔定理（Hall&amp;rsquo;s Theorem）是图论中的一个重要定理，主要用于解决二部图的完美匹配问题。它的内容如下：&lt;/p>
&lt;p>在一个二部图中，如果对于左侧的每个顶点集合，其邻接的右侧顶点集合的大小至少与其一样大，那么这个二部图存在一个完美匹配。&lt;/p>
&lt;p>更形式化地说，设 G=(V,E) 是一个二部图，V 可以分为两个部分 V1 和 V2。如果对于 V1 中的任意子集 S，都有 |N(S)| &amp;gt;= |S|，其中 N(S) 是 S 中所有顶点的邻接顶点集合，那么 G 中存在一个完美匹配。&lt;/p>
&lt;p>这个定理在组合优化、网络流和匹配理论等领域有广泛的应用。例如，它可以用来解决任务分配问题、婚配问题等。&lt;/p>
&lt;p>Hall定理是用于解决二部图中的完美匹配问题的，而流网络中的需求循环问题则需要使用不同的方法来解决。&lt;/p>
&lt;p>在流网络中，每个节点都有一个需求，表示流入该节点的流量和流出该节点的流量之间的差值。一个需求循环是一个满足所有节点需求的流。&lt;/p>
&lt;p>要解决需求循环问题，我们可以使用以下步骤：&lt;/p>
&lt;ol>
&lt;li>添加一个新的源节点s和一个新的汇点t。&lt;/li>
&lt;li>对于每个需求为d的节点v，如果d &amp;gt; 0，那么添加一条从s到v的边，容量为d；如果d &amp;lt; 0，那么添加一条从v到t的边，容量为-d。&lt;/li>
&lt;li>在新的网络中找到一个最大流。如果这个最大流的值等于所有正需求的总和，那么原网络存在一个需求循环。否则，原网络不存在需求循环。&lt;/li>
&lt;/ol>
&lt;p>这个方法的正确性基于最大流最小割定理：在一个流网络中，最大流的值等于最小割的容量。在这个问题中，最小割就是将所有正需求的节点和所有负需求的节点分开的割，其容量就是所有正需求的总和。所以，如果最大流的值等于所有正需求的总和，那么就存在一个需求循环。反之，如果存在一个需求循环，那么最大流的值必然等于所有正需求的总和。&lt;/p></description></item><item><title>COMP90077</title><link>https://shyu216.github.io/aquamega/p/comp90077/</link><pubDate>Sun, 09 Jun 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/comp90077/</guid><description>&lt;p>Learn some advanced algorithms and data structures.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Treap&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Admortized Analysis: Prepaid/Potential&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Quake Heap&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Splay Tree&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Perfect Hashing/Cuckoo Hashing&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Range Tree&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Min Cut/Max Flow&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Karger&amp;rsquo;s algorithm: 找最小割, 找多次取最优, 随机地找两个节点合并, 直到只剩下两个节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Ford-Fulkerson algorithm: 最早的最大流算法, 重复地找增广路径, 直到找不到&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Edmonds-Karp algorithm: 用BFS找增广路径, complexity更低&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Hall&amp;rsquo;s theorem: 一个二分图存在完美匹配当且仅当对于每一个子集, 子集的大小大于等于子集的邻居的大小&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="readings">Readings
&lt;/h2>&lt;ul>
&lt;li>Karger&amp;rsquo;s Randomised Contraction algorithm: Chapter 13.2 of [KT]&lt;/li>
&lt;li>Flow networks, max flow, min cut and basic Ford-Fulkerson: Chapter 7.1 - 7.2 of [KT] and also Chapter 10.1 - 10.4 of [JE]&lt;/li>
&lt;li>Flow network applications (Bipartite Matching and Disjoint Paths): Chapter 7.5-7.6 of [KT]&lt;/li>
&lt;li>Capacity-Scaling: Chapter 7.3 of [KT]Edmonds-Karps algorithms: Chapter 10.6 of [JE]&lt;/li>
&lt;li>Circulation with demands: Chapter 7.7 of [KT]&lt;/li>
&lt;li>Linear Programming: &lt;a class="link" href="https://jeffe.cs.illinois.edu/teaching/algorithms/notes/H-lp.pdf" target="_blank" rel="noopener"
>https://jeffe.cs.illinois.edu/teaching/algorithms/notes/H-lp.pdf&lt;/a>&lt;/li>
&lt;li>Approximation Algorithms: Chapter 1 of &lt;a class="link" href="https://www.designofapproxalgs.com/book.pdf" target="_blank" rel="noopener"
>https://www.designofapproxalgs.com/book.pdf&lt;/a> and see also Approximation Algorithms by Vazirani&lt;/li>
&lt;li>[JE] = &lt;a class="link" href="https://jeffe.cs.illinois.edu/teaching/algorithms/book/Algorithms-JeffE.pdf" target="_blank" rel="noopener"
>https://jeffe.cs.illinois.edu/teaching/algorithms/book/Algorithms-JeffE.pdf&lt;/a>&lt;/li>
&lt;li>[KT] = Algorithm Design by Kleinberg and Tardos&lt;/li>
&lt;/ul>
&lt;h2 id="vocabs">Vocabs
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>asymptotic notation: 渐进符号&lt;/p>
&lt;/li>
&lt;li>
&lt;p>subtle: 微妙的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>conjecture: 猜想&lt;/p>
&lt;/li>
&lt;li>
&lt;p>concave: 凹的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>invalidate: 使无效&lt;/p>
&lt;/li>
&lt;li>
&lt;p>conceptual: 概念上的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>dominate: 支配&lt;/p>
&lt;/li>
&lt;li>
&lt;p>trial: 尝试&lt;/p>
&lt;/li>
&lt;li>
&lt;p>prime: 素数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>evict: 驱逐&lt;/p>
&lt;/li>
&lt;li>
&lt;p>disjoint: 不相交的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>fraction: 分数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cascadinng: 级联&lt;/p>
&lt;/li>
&lt;li>
&lt;p>auxilinary: 辅助的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sink: 汇点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>discrepency: 差异&lt;/p>
&lt;/li>
&lt;li>
&lt;p>incoporate: 合并&lt;/p>
&lt;/li>
&lt;li>
&lt;p>converse: 相反的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sought: 寻找&lt;/p>
&lt;/li>
&lt;li>
&lt;p>polytope: 多面体&lt;/p>
&lt;/li>
&lt;li>
&lt;p>incident: 相邻的&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;Incident&amp;rdquo;：当我们说一条边和一个顶点是&amp;quot;incident&amp;quot;（相邻），意味着这条边的一个端点就是这个顶点。&lt;/li>
&lt;li>&amp;ldquo;Adjacent&amp;rdquo;：当我们说两个顶点是&amp;quot;adjacent&amp;quot;（邻接），意味着存在一条边连接这两个顶点。同样，当我们说两条边是&amp;quot;adjacent&amp;quot;（邻接），意味着这两条边共享一个公共顶点。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>feasible: 可行的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>polynomial: 多项式&lt;/p>
&lt;/li>
&lt;li>
&lt;p>comprise: 包括&lt;/p>
&lt;/li>
&lt;li>
&lt;p>logarithmic: 对数的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rounding: 四舍五入&lt;/p>
&lt;/li>
&lt;li>
&lt;p>infeasible: 不可行的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>unbounded: 无界的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>reciprocal: 倒数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>incremental: 增量的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>conservation: 保守&lt;/p>
&lt;/li>
&lt;li>
&lt;p>slackness: 松弛&lt;/p>
&lt;/li>
&lt;li>
&lt;p>conservation node: 保守节点, a node that has the same flow in and out&lt;/p>
&lt;/li>
&lt;li>
&lt;p>residual graph: 残余图, a graph that represents the remaining capacity of each edge&lt;/p>
&lt;/li>
&lt;li>
&lt;p>augmenting path: 增广路径, a path from source to sink in the residual graph&lt;/p>
&lt;/li>
&lt;li>
&lt;p>feasible flow: 可行流, a flow that satisfies the capacity constraints and conservation constraints&lt;/p>
&lt;/li>
&lt;li>
&lt;p>perfect matching: 完美匹配, a matching that covers all the nodes&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bipartite graph: 二分图, a graph that can be divided into two sets such that all edges are between the two sets&lt;/p>
&lt;/li>
&lt;li>
&lt;p>disjoint paths: 不相交路径, paths that do not share any nodes&lt;/p>
&lt;/li>
&lt;li>
&lt;p>vertex cover: 顶点覆盖, a set of vertices that covers all the edges&lt;/p>
&lt;/li>
&lt;li>
&lt;p>maximal matching: 最大匹配, a matching that cannot be extended by adding another edge&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cardinality 基数，集合中元素的数量&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Dynamic Array</title><link>https://shyu216.github.io/aquamega/p/dynamic-array/</link><pubDate>Thu, 02 May 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/dynamic-array/</guid><description>&lt;ul>
&lt;li>Insertion: O(1) expected, O(n) worst case&lt;/li>
&lt;li>Search: O(n) expected, O(n) worst case&lt;/li>
&lt;li>Deletion: O(n) expected, O(n) worst case&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">DynamicArray&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c1"># Number of elements&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="c1"># Initial capacity&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">A&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_make_array&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">capacity&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__len__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">n&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__getitem__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">raise&lt;/span> &lt;span class="ne">IndexError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;invalid index&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> element = (id,key)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">capacity&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_resize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">capacity&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">element&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">delete&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">keydel&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">keydel&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">capacity&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_resize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">capacity&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">keysch&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">element&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">keysch&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">element&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">_resize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">new_cap&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">B&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_make_array&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">new_cap&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">B&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">A&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">B&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">capacity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">new_cap&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">_make_array&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">new_cap&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="kc">None&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">new_cap&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Treap</title><link>https://shyu216.github.io/aquamega/p/treap/</link><pubDate>Thu, 02 May 2024 00:00:00 +0000</pubDate><guid>https://shyu216.github.io/aquamega/p/treap/</guid><description>&lt;ul>
&lt;li>Tree + Heap = Treap&lt;/li>
&lt;li>Insertion: O(log n) expected, O(n) worst case&lt;/li>
&lt;li>Search: O(log n) expected, O(n) worst case&lt;/li>
&lt;li>Deletion: O(log n) expected, O(n) worst case&lt;/li>
&lt;/ul>
&lt;p>treap的key是有用的数据；priority是随机生成的值，用于保持treap的平衡。&lt;/p>
&lt;h2 id="operations">Operations
&lt;/h2>&lt;h3 id="insertion">Insertion
&lt;/h3>&lt;p>加到叶子节点，然后向上旋转，直到满足treap的性质。&lt;/p>
&lt;h3 id="deletion">Deletion
&lt;/h3>&lt;p>找到要删除的节点，把priority设为无穷大，然后旋转，直到满足treap的性质。此时，要删除的节点就变成了叶子节点，然后删除。&lt;/p>
&lt;h3 id="search">Search
&lt;/h3>&lt;p>和BST一样，递归地搜索左子树或右子树。&lt;/p>
&lt;h3 id="join">Join
&lt;/h3>&lt;p>搞一个假的节点，priority设为无穷大，然后把两个treap的根节点作为左右子树，然后旋转，直到满足treap的性质。&lt;/p>
&lt;h3 id="split">Split
&lt;/h3>&lt;p>把要split的key找到，设成无穷小，然后旋转，直到满足treap的性质。此时，这个key到根节点了。&lt;/p>
&lt;h2 id="implementation">Implementation
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;span class="lnt">65
&lt;/span>&lt;span class="lnt">66
&lt;/span>&lt;span class="lnt">67
&lt;/span>&lt;span class="lnt">68
&lt;/span>&lt;span class="lnt">69
&lt;/span>&lt;span class="lnt">70
&lt;/span>&lt;span class="lnt">71
&lt;/span>&lt;span class="lnt">72
&lt;/span>&lt;span class="lnt">73
&lt;/span>&lt;span class="lnt">74
&lt;/span>&lt;span class="lnt">75
&lt;/span>&lt;span class="lnt">76
&lt;/span>&lt;span class="lnt">77
&lt;/span>&lt;span class="lnt">78
&lt;/span>&lt;span class="lnt">79
&lt;/span>&lt;span class="lnt">80
&lt;/span>&lt;span class="lnt">81
&lt;/span>&lt;span class="lnt">82
&lt;/span>&lt;span class="lnt">83
&lt;/span>&lt;span class="lnt">84
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">random&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Node&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">priority&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">id&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">key&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">key&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">priority&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">priority&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Treap&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">_left_rotate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">right_child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">right&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">right_child&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">left&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">right_child&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">right_child&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">_right_rotate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">left_child&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">left&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left_child&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">right&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">left_child&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">left_child&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">element&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">element&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">random&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">random&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_insert_node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">_insert_node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">node&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">key&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_insert_node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">priority&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">priority&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_right_rotate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_insert_node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">priority&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">priority&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_left_rotate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">root&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">delete&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">keydel&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_delete_node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">keydel&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">_delete_node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">keydel&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">keydel&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_delete_node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">keydel&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">elif&lt;/span> &lt;span class="n">keydel&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_delete_node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">keydel&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">elif&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">right&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">elif&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">left&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">priority&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">priority&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_right_rotate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_delete_node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">keydel&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_left_rotate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_delete_node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">keydel&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">root&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">search&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_search_node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">_search_node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">key&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">elif&lt;/span> &lt;span class="n">key&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_search_node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">left&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_search_node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">right&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item></channel></rss>