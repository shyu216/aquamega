---
date: 2024-06-11
draft: false
title: Admortized Analysis
categories:
    - COMP90077
tags: 
    - Analysis
---


$\sum_{i=1}^{m} cost(\sigma_i) \leq \sum_{i=1}^{m} a(\sigma_i)$

摊还分析是一种分析数据结构操作成本的方法，它将操作的成本在一系列操作中进行平均，而不是单独考虑每个操作。

我们的目标是证明对于任何一系列的动态数组操作 $\sigma_1,...,\sigma_m$，如果每个操作的摊还成本 $a(\sigma_i)$ 是 $O(1)$（即常数时间），那么整体的成本不等式 $\sum_{i=1}^{m} cost(\sigma_i) \leq \sum_{i=1}^{m} a(\sigma_i)$ 就能成立。

这个不等式的含义是，所有操作的实际总成本（左边的部分）不会超过所有操作的摊还总成本（右边的部分）。这是摊还分析的一个重要性质，它保证了我们的摊还成本确实反映了实际的成本。

## Prepaid

$\sum_{i=1}^{m} a(\sigma_i) = \sum_{i=1}^{m} cost(\sigma_i) + \sum_{i=1}^{m} \Beta$

where $\Beta \geq 0$ (总是有余额)


"Prepaid"（预付）是摊还分析中的一个概念，它描述的是一种策略，即在执行一些高成本的操作之前，先执行一些低成本的操作来“预付”高成本操作的部分或全部成本。

例如，考虑一个动态数组的插入操作。当数组满时，我们需要分配一个新的、更大的数组，并将旧数组中的所有元素复制到新数组中。这个操作的成本是线性的。然而，如果我们将这个成本均摊到之前的每次插入操作上，那么每次插入操作的摊还成本就是常数的。这就是预付策略的一个例子：我们通过每次插入操作“预付”一部分成本，来避免在数组满时一次性支付所有的成本。

预付策略的一个关键思想是，我们可以将一些高成本的操作的成本分摊到多个低成本的操作上，从而使得所有操作的摊还成本都保持在一个可接受的范围内。这种策略在设计和分析高效的数据结构和算法时非常有用。


## Potential Function

$\sum_{i=1}^{m} a(\sigma_i) = \sum_{i=1}^{m} cost(\sigma_i) + \sum_{i=1}^{m} \Phi(D_i) - \Phi(D_0)$

where $\Phi(D_0)$ = 0, $\Phi(D_i) \geq 0$（不能超出势能）

在摊还分析中，我们经常使用势能方法来证明摊还成本。下面是一个经典的例子：动态数组的插入操作。

动态数组是一种可以动态增长和缩小的数组。当我们向动态数组中插入元素时，如果数组已满，我们需要创建一个新的、更大的数组，然后将旧数组中的所有元素复制到新数组中。这个操作的成本是线性的。然而，如果我们使用摊还分析，我们可以证明每次插入操作的摊还成本是常数的。

我们定义势能函数 $\Phi$ 为数组的当前大小减去数组中的元素数量。当我们插入一个元素时，有两种情况：

1. 如果数组没有满，我们只需要在数组的末尾添加一个元素。这个操作的实际成本是 $1$，势能的变化是 $-1$，所以摊还成本是 $1 - (-1) = 2$。

2. 如果数组已满，我们需要创建一个新的、大小为 $2n$ 的数组，并将 $n$ 个元素复制到新数组中。这个操作的实际成本是 $n+1$，势能的变化是 $n - n = 0$，所以摊还成本是 $n+1 - 0 = n+1$。

在第二种情况中，摊还成本看起来是线性的。然而，这种情况只会发生在插入操作的数量是当前数组大小的整数倍时。在大多数情况下，我们处于第一种情况，摊还成本是常数的。因此，我们可以说插入操作的摊还成本是常数的，即 $a(\sigma_i) \in O(1)$。